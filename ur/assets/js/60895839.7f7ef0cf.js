"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[947],{2509:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var s=n(4848),i=n(8453);const t={sidebar_position:9,title:"Perception Systems",description:"Computer vision, sensor processing, and environmental understanding",slug:"/perception"},a="Perception Systems",o={id:"perception/index",title:"Perception Systems",description:"Computer vision, sensor processing, and environmental understanding",source:"@site/docs/perception/index.mdx",sourceDirName:"perception",slug:"/perception",permalink:"/Humanoid-Robotic-Book/ur/docs/perception",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/perception/index.mdx",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9,title:"Perception Systems",description:"Computer vision, sensor processing, and environmental understanding",slug:"/perception"},sidebar:"tutorialSidebar",previous:{title:"Motion Planning & Control",permalink:"/Humanoid-Robotic-Book/ur/docs/motion-planning"},next:{title:"Learning & Adaptation",permalink:"/Humanoid-Robotic-Book/ur/docs/learning-adaptation/"}},l={},c=[{value:"Introduction to Perception Systems",id:"introduction-to-perception-systems",level:2},{value:"Core Components of Perception Systems",id:"core-components-of-perception-systems",level:3},{value:"Camera-Based Perception",id:"camera-based-perception",level:2},{value:"Image Processing Fundamentals",id:"image-processing-fundamentals",level:3},{value:"Feature Detection and Matching",id:"feature-detection-and-matching",level:3},{value:"Object Detection with Deep Learning",id:"object-detection-with-deep-learning",level:3},{value:"Depth Perception",id:"depth-perception",level:2},{value:"Stereo Vision",id:"stereo-vision",level:3},{value:"LIDAR Processing",id:"lidar-processing",level:3},{value:"Sensor Fusion",id:"sensor-fusion",level:2},{value:"Kalman Filter for Sensor Fusion",id:"kalman-filter-for-sensor-fusion",level:3},{value:"Particle Filter for Non-linear Systems",id:"particle-filter-for-non-linear-systems",level:3},{value:"SLAM (Simultaneous Localization and Mapping)",id:"slam-simultaneous-localization-and-mapping",level:2},{value:"Visual SLAM",id:"visual-slam",level:3},{value:"Hardware-Specific Optimizations",id:"hardware-specific-optimizations",level:2},{value:"For NVIDIA Jetson Users",id:"for-nvidia-jetson-users",level:3},{value:"For High-End GPU Users",id:"for-high-end-gpu-users",level:3},{value:"3D Perception and Reconstruction",id:"3d-perception-and-reconstruction",level:2},{value:"Point Cloud Processing",id:"point-cloud-processing",level:3},{value:"Perception Quality Assessment",id:"perception-quality-assessment",level:2},{value:"Performance Metrics",id:"performance-metrics",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Practice Exercises",id:"practice-exercises",level:2},{value:"Exercise 1: Feature Detection",id:"exercise-1-feature-detection",level:3},{value:"Exercise 2: Sensor Fusion",id:"exercise-2-sensor-fusion",level:3},{value:"Exercise 3: SLAM Implementation",id:"exercise-3-slam-implementation",level:3},{value:"Exercise 4: 3D Reconstruction",id:"exercise-4-3d-reconstruction",level:3},{value:"Exercise 5: Hardware Optimization",id:"exercise-5-hardware-optimization",level:3},{value:"MCQs Quiz",id:"mcqs-quiz",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const r={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h1,{id:"perception-systems",children:"Perception Systems"}),"\n",(0,s.jsx)(r.h2,{id:"introduction-to-perception-systems",children:"Introduction to Perception Systems"}),"\n",(0,s.jsx)(r.p,{children:"Perception systems form the sensory foundation of autonomous robots, enabling them to interpret and understand their environment through various sensors. These systems process raw sensor data to extract meaningful information about objects, obstacles, surfaces, and other environmental features necessary for navigation, manipulation, and interaction."}),"\n",(0,s.jsx)(r.h3,{id:"core-components-of-perception-systems",children:"Core Components of Perception Systems"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Visual Perception"}),": Processing camera images for object detection, recognition, and scene understanding"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Depth Perception"}),": Using stereo cameras, LIDAR, or structured light for 3D scene reconstruction"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Spatial Mapping"}),": Creating representations of the environment (occupancy grids, point clouds, meshes)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Object Recognition"}),": Identifying and classifying objects in the environment"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Sensor Fusion"}),": Combining data from multiple sensors for robust perception"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"State Estimation"}),": Determining robot pose and motion using sensor data"]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-mermaid",children:"graph TD\r\n    A[Perception System] --\x3e B[Visual Processing]\r\n    A --\x3e C[Depth Processing]\r\n    A --\x3e D[Sensor Fusion]\r\n    A --\x3e E[State Estimation]\r\n\r\n    B --\x3e B1[Image Processing]\r\n    B --\x3e B2[Feature Detection]\r\n    B --\x3e B3[Object Recognition]\r\n    B --\x3e B4[Scene Understanding]\r\n\r\n    C --\x3e C1[LIDAR Processing]\r\n    C --\x3e C2[Stereo Vision]\r\n    C --\x3e C3[Depth Estimation]\r\n    C --\x3e C4[3D Reconstruction]\r\n\r\n    D --\x3e D1[Multi-sensor Integration]\r\n    D --\x3e D2[Data Association]\r\n    D --\x3e D3[Uncertainty Management]\r\n    D --\x3e D4[Consistent Representation]\r\n\r\n    E --\x3e E1[Visual Odometry]\r\n    E --\x3e E2[SLAM]\r\n    E --\x3e E3[IMU Integration]\r\n    E --\x3e E4[Particle Filtering]\r\n\r\n    F[Environmental Model] --\x3e A\r\n    F --\x3e F1[Occupancy Grids]\r\n    F --\x3e F2[Point Clouds]\r\n    F --\x3e F3[Semantic Maps]\r\n    F --\x3e F4[Topological Maps]\n"})}),"\n",(0,s.jsx)(r.h2,{id:"camera-based-perception",children:"Camera-Based Perception"}),"\n",(0,s.jsx)(r.h3,{id:"image-processing-fundamentals",children:"Image Processing Fundamentals"}),"\n",(0,s.jsx)(r.p,{children:"Camera-based perception starts with fundamental image processing techniques:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Image\r\nfrom cv_bridge import CvBridge\r\nimport cv2\r\nimport numpy as np\r\nfrom std_msgs.msg import Header\r\nfrom visualization_msgs.msg import Marker, MarkerArray\r\n\r\nclass CameraPerceptionNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'camera_perception_node\')\r\n\r\n        # Initialize CV bridge\r\n        self.cv_bridge = CvBridge()\r\n\r\n        # Create subscriber for camera images\r\n        self.image_sub = self.create_subscription(\r\n            Image, \'/camera/image_raw\', self.image_callback, 10)\r\n\r\n        # Create publisher for processed images\r\n        self.processed_image_pub = self.create_publisher(\r\n            Image, \'/processed_image\', 10)\r\n\r\n        # Create publisher for visualization markers\r\n        self.marker_pub = self.create_publisher(\r\n            MarkerArray, \'/perception_markers\', 10)\r\n\r\n        self.get_logger().info(\'Camera perception node initialized\')\r\n\r\n    def image_callback(self, msg):\r\n        """Process incoming camera image"""\r\n        try:\r\n            # Convert ROS Image to OpenCV\r\n            cv_image = self.cv_bridge.imgmsg_to_cv2(msg, "bgr8")\r\n\r\n            # Apply various image processing techniques\r\n            processed_image = self.process_image(cv_image)\r\n\r\n            # Detect features in the image\r\n            features = self.detect_features(processed_image)\r\n\r\n            # Publish processed image\r\n            processed_msg = self.cv_bridge.cv2_to_imgmsg(processed_image, "bgr8")\r\n            processed_msg.header = msg.header\r\n            self.processed_image_pub.publish(processed_msg)\r\n\r\n            # Publish visualization markers\r\n            markers = self.create_visualization_markers(features, msg.header)\r\n            self.marker_pub.publish(markers)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error processing image: {e}\')\r\n\r\n    def process_image(self, image):\r\n        """Apply basic image processing techniques"""\r\n        # Convert to grayscale\r\n        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\r\n\r\n        # Apply Gaussian blur to reduce noise\r\n        blurred = cv2.GaussianBlur(gray, (5, 5), 0)\r\n\r\n        # Apply adaptive thresholding\r\n        thresh = cv2.adaptiveThreshold(blurred, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)\r\n\r\n        # Convert back to BGR for visualization\r\n        processed = cv2.cvtColor(thresh, cv2.COLOR_GRAY2BGR)\r\n\r\n        return processed\r\n\r\n    def detect_features(self, image):\r\n        """Detect features in the image"""\r\n        # Convert to grayscale if needed\r\n        if len(image.shape) == 3:\r\n            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\r\n        else:\r\n            gray = image\r\n\r\n        # Detect corners using Shi-Tomasi corner detector\r\n        corners = cv2.goodFeaturesToTrack(\r\n            gray,\r\n            maxCorners=100,\r\n            qualityLevel=0.01,\r\n            minDistance=10,\r\n            blockSize=3\r\n        )\r\n\r\n        features = []\r\n        if corners is not None:\r\n            for corner in corners:\r\n                x, y = corner.ravel()\r\n                features.append((int(x), int(y)))\r\n\r\n        return features\r\n\r\n    def create_visualization_markers(self, features, header):\r\n        """Create visualization markers for detected features"""\r\n        marker_array = MarkerArray()\r\n\r\n        for i, (x, y) in enumerate(features):\r\n            marker = Marker()\r\n            marker.header = header\r\n            marker.ns = "features"\r\n            marker.id = i\r\n            marker.type = Marker.CYLINDER\r\n            marker.action = Marker.ADD\r\n\r\n            # Position\r\n            marker.pose.position.x = x / 100.0  # Scale down for visualization\r\n            marker.pose.position.y = y / 100.0\r\n            marker.pose.position.z = 0.0\r\n            marker.pose.orientation.w = 1.0\r\n\r\n            # Scale\r\n            marker.scale.x = 0.02\r\n            marker.scale.y = 0.02\r\n            marker.scale.z = 0.01\r\n\r\n            # Color (red)\r\n            marker.color.r = 1.0\r\n            marker.color.g = 0.0\r\n            marker.color.b = 0.0\r\n            marker.color.a = 1.0\r\n\r\n            marker_array.markers.append(marker)\r\n\r\n        return marker_array\n'})}),"\n",(0,s.jsx)(r.h3,{id:"feature-detection-and-matching",children:"Feature Detection and Matching"}),"\n",(0,s.jsx)(r.p,{children:"Feature detection is crucial for many perception tasks:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'class FeatureDetectionNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'feature_detection_node\')\r\n\r\n        # Initialize CV bridge\r\n        self.cv_bridge = CvBridge()\r\n\r\n        # Create subscriber and publisher\r\n        self.image_sub = self.create_subscription(\r\n            Image, \'/camera/image_raw\', self.image_callback, 10)\r\n        self.features_pub = self.create_publisher(\r\n            Image, \'/feature_overlay\', 10)\r\n\r\n        # Initialize different feature detectors\r\n        self.sift = cv2.SIFT_create()\r\n        self.surf = cv2.xfeatures2d.SURF_create() if hasattr(cv2.xfeatures2d, \'SURF_create\') else None\r\n        self.orb = cv2.ORB_create()\r\n\r\n        self.get_logger().info(\'Feature detection node initialized\')\r\n\r\n    def image_callback(self, msg):\r\n        """Process image and detect features"""\r\n        try:\r\n            cv_image = self.cv_bridge.imgmsg_to_cv2(msg, "bgr8")\r\n\r\n            # Detect features using different methods\r\n            keypoints_sift, descriptors_sift = self.detect_sift_features(cv_image)\r\n            keypoints_orb, descriptors_orb = self.detect_orb_features(cv_image)\r\n\r\n            # Create overlay with features\r\n            overlay_image = self.create_feature_overlay(cv_image, keypoints_sift, keypoints_orb)\r\n\r\n            # Publish overlay\r\n            overlay_msg = self.cv_bridge.cv2_to_imgmsg(overlay_image, "bgr8")\r\n            overlay_msg.header = msg.header\r\n            self.features_pub.publish(overlay_msg)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error in feature detection: {e}\')\r\n\r\n    def detect_sift_features(self, image):\r\n        """Detect SIFT features"""\r\n        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\r\n        keypoints, descriptors = self.sift.detectAndCompute(gray, None)\r\n        return keypoints, descriptors\r\n\r\n    def detect_orb_features(self, image):\r\n        """Detect ORB features"""\r\n        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\r\n        keypoints, descriptors = self.orb.detectAndCompute(gray, None)\r\n        return keypoints, descriptors\r\n\r\n    def create_feature_overlay(self, image, sift_keypoints, orb_keypoints):\r\n        """Create image overlay with detected features"""\r\n        overlay = image.copy()\r\n\r\n        # Draw SIFT keypoints in red\r\n        if sift_keypoints:\r\n            overlay = cv2.drawKeypoints(\r\n                overlay, sift_keypoints, None,\r\n                color=(0, 0, 255),\r\n                flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS\r\n            )\r\n\r\n        # Draw ORB keypoints in blue\r\n        if orb_keypoints:\r\n            overlay = cv2.drawKeypoints(\r\n                overlay, orb_keypoints, None,\r\n                color=(255, 0, 0),\r\n                flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS\r\n            )\r\n\r\n        return overlay\n'})}),"\n",(0,s.jsx)(r.h3,{id:"object-detection-with-deep-learning",children:"Object Detection with Deep Learning"}),"\n",(0,s.jsx)(r.p,{children:"Modern perception systems often use deep learning for object detection:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"import torch\r\nimport torchvision\r\nfrom torchvision import transforms\r\nfrom PIL import Image as PILImage\r\nimport io\r\n\r\nclass DeepObjectDetectionNode(Node):\r\n    def __init__(self):\r\n        super().__init__('deep_object_detection_node')\r\n\r\n        # Initialize CV bridge\r\n        self.cv_bridge = CvBridge()\r\n\r\n        # Load pre-trained object detection model\r\n        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\r\n        self.model = torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=True)\r\n        self.model.to(self.device)\r\n        self.model.eval()\r\n\r\n        # Define COCO dataset classes\r\n        self.coco_names = [\r\n            '__background__', 'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus',\r\n            'train', 'truck', 'boat', 'traffic light', 'fire hydrant', 'stop sign',\r\n            'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow',\r\n            'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag',\r\n            'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball', 'kite',\r\n            'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',\r\n            'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana',\r\n            'apple', 'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza',\r\n            'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed', 'dining table',\r\n            'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone',\r\n            'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 'book', 'clock',\r\n            'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'\r\n        ]\r\n\r\n        # Create subscriber and publisher\r\n        self.image_sub = self.create_subscription(\r\n            Image, '/camera/image_raw', self.image_callback, 10)\r\n        self.detection_pub = self.create_publisher(\r\n            Image, '/detection_overlay', 10)\r\n\r\n        # Image preprocessing\r\n        self.transform = transforms.Compose([\r\n            transforms.ToTensor(),\r\n        ])\r\n\r\n        self.get_logger().info('Deep object detection node initialized')\r\n\r\n    def image_callback(self, msg):\r\n        \"\"\"Process image and detect objects using deep learning\"\"\"\r\n        try:\r\n            cv_image = self.cv_bridge.imgmsg_to_cv2(msg, \"bgr8\")\r\n\r\n            # Convert OpenCV image to PIL\r\n            pil_image = PILImage.fromarray(cv_image)\r\n\r\n            # Preprocess image\r\n            input_tensor = self.transform(pil_image).unsqueeze(0).to(self.device)\r\n\r\n            # Run object detection\r\n            with torch.no_grad():\r\n                predictions = self.model(input_tensor)\r\n\r\n            # Process predictions\r\n            processed_image = self.draw_detections(cv_image, predictions, msg.header)\r\n\r\n            # Publish result\r\n            result_msg = self.cv_bridge.cv2_to_imgmsg(processed_image, \"bgr8\")\r\n            result_msg.header = msg.header\r\n            self.detection_pub.publish(result_msg)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error in deep object detection: {e}')\r\n\r\n    def draw_detections(self, image, predictions, header):\r\n        \"\"\"Draw detection results on image\"\"\"\r\n        # Get the first (and typically only) image results\r\n        pred = {key: value[0].cpu() for key, value in predictions.items()}\r\n\r\n        boxes = pred['boxes'].numpy()\r\n        labels = pred['labels'].numpy()\r\n        scores = pred['scores'].numpy()\r\n\r\n        # Filter detections by confidence threshold\r\n        threshold = 0.5\r\n        valid_detections = scores > threshold\r\n\r\n        overlay = image.copy()\r\n\r\n        for i, valid in enumerate(valid_detections):\r\n            if valid:\r\n                box = boxes[i]\r\n                label = int(labels[i])\r\n                score = scores[i]\r\n\r\n                # Draw bounding box\r\n                x1, y1, x2, y2 = map(int, box)\r\n                cv2.rectangle(overlay, (x1, y1), (x2, y2), (0, 255, 0), 2)\r\n\r\n                # Draw label and confidence\r\n                label_text = f\"{self.coco_names[label]}: {score:.2f}\"\r\n                cv2.putText(\r\n                    overlay, label_text, (x1, y1 - 10),\r\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2\r\n                )\r\n\r\n        return overlay\n"})}),"\n",(0,s.jsx)(r.h2,{id:"depth-perception",children:"Depth Perception"}),"\n",(0,s.jsx)(r.h3,{id:"stereo-vision",children:"Stereo Vision"}),"\n",(0,s.jsx)(r.p,{children:"Stereo vision systems estimate depth by comparing images from two cameras:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'class StereoVisionNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'stereo_vision_node\')\r\n\r\n        # Initialize CV bridge\r\n        self.cv_bridge = CvBridge()\r\n\r\n        # Create subscribers for left and right cameras\r\n        self.left_sub = self.create_subscription(\r\n            Image, \'/stereo_camera/left/image_rect_color\', self.left_image_callback, 10)\r\n        self.right_sub = self.create_subscription(\r\n            Image, \'/stereo_camera/right/image_rect_color\', self.right_image_callback, 10)\r\n\r\n        # Create publisher for disparity map\r\n        self.disparity_pub = self.create_publisher(\r\n            Image, \'/disparity_map\', 10)\r\n        self.depth_pub = self.create_publisher(\r\n            Image, \'/depth_image\', 10)\r\n\r\n        # Initialize stereo matcher\r\n        self.stereo = cv2.StereoSGBM_create(\r\n            minDisparity=0,\r\n            numDisparities=96,  # Must be divisible by 16\r\n            blockSize=5,\r\n            P1=8 * 3 * 5**2,\r\n            P2=32 * 3 * 5**2,\r\n            disp12MaxDiff=1,\r\n            uniquenessRatio=15,\r\n            speckleWindowSize=0,\r\n            speckleRange=2,\r\n            preFilterCap=63,\r\n            mode=cv2.STEREO_SGBM_MODE_SGBM_3WAY\r\n        )\r\n\r\n        # Camera parameters (these would come from calibration)\r\n        self.baseline = 0.12  # Baseline in meters\r\n        self.focal_length = 320  # Focal length in pixels (example value)\r\n\r\n        # Store images until both are available\r\n        self.left_image = None\r\n        self.right_image = None\r\n        self.left_timestamp = None\r\n        self.right_timestamp = None\r\n\r\n        self.get_logger().info(\'Stereo vision node initialized\')\r\n\r\n    def left_image_callback(self, msg):\r\n        """Process left camera image"""\r\n        try:\r\n            self.left_image = self.cv_bridge.imgmsg_to_cv2(msg, "mono8")\r\n            self.left_timestamp = msg.header.stamp\r\n\r\n            # If we have both images, process them\r\n            if self.right_image is not None:\r\n                self.process_stereo_pair()\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error processing left image: {e}\')\r\n\r\n    def right_image_callback(self, msg):\r\n        """Process right camera image"""\r\n        try:\r\n            self.right_image = self.cv_bridge.imgmsg_to_cv2(msg, "mono8")\r\n            self.right_timestamp = msg.header.stamp\r\n\r\n            # If we have both images, process them\r\n            if self.left_image is not None:\r\n                self.process_stereo_pair()\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error processing right image: {e}\')\r\n\r\n    def process_stereo_pair(self):\r\n        """Process stereo image pair to generate disparity and depth"""\r\n        if self.left_image is None or self.right_image is None:\r\n            return\r\n\r\n        try:\r\n            # Compute disparity map\r\n            disparity = self.stereo.compute(self.left_image, self.right_image).astype(np.float32) / 16.0\r\n\r\n            # Convert disparity to depth\r\n            depth = self.disparity_to_depth(disparity)\r\n\r\n            # Publish disparity map\r\n            disparity_msg = self.cv_bridge.cv2_to_imgmsg(disparity, "32FC1")\r\n            disparity_msg.header = self.left_timestamp  # Use the earlier timestamp\r\n            self.disparity_pub.publish(disparity_msg)\r\n\r\n            # Publish depth image\r\n            depth_msg = self.cv_bridge.cv2_to_imgmsg(depth, "32FC1")\r\n            depth_msg.header = self.left_timestamp\r\n            self.depth_pub.publish(depth_msg)\r\n\r\n            # Reset images after processing\r\n            self.left_image = None\r\n            self.right_image = None\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error processing stereo pair: {e}\')\r\n\r\n    def disparity_to_depth(self, disparity):\r\n        """Convert disparity map to depth map"""\r\n        # Depth = (baseline * focal_length) / disparity\r\n        # Add small value to avoid division by zero\r\n        depth = np.zeros_like(disparity)\r\n        valid_pixels = disparity > 0\r\n        depth[valid_pixels] = (self.baseline * self.focal_length) / (disparity[valid_pixels] + 1e-6)\r\n        return depth\n'})}),"\n",(0,s.jsx)(r.h3,{id:"lidar-processing",children:"LIDAR Processing"}),"\n",(0,s.jsx)(r.p,{children:"LIDAR sensors provide accurate depth information:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'from sensor_msgs.msg import LaserScan, PointCloud2\r\nimport sensor_msgs.point_cloud2 as pc2\r\nfrom geometry_msgs.msg import Point32\r\n\r\nclass LIDARPerceptionNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'lidar_perception_node\')\r\n\r\n        # Create subscriber for LIDAR scan\r\n        self.scan_sub = self.create_subscription(\r\n            LaserScan, \'/scan\', self.scan_callback, 10)\r\n\r\n        # Create subscriber for point cloud (if available)\r\n        self.pc_sub = self.create_subscription(\r\n            PointCloud2, \'/point_cloud\', self.pointcloud_callback, 10)\r\n\r\n        # Create publisher for processed data\r\n        self.obstacle_pub = self.create_publisher(\r\n            PointCloud2, \'/obstacles\', 10)\r\n        self.free_space_pub = self.create_publisher(\r\n            PointCloud2, \'/free_space\', 10)\r\n\r\n        # LIDAR parameters\r\n        self.min_range = 0.1\r\n        self.max_range = 10.0\r\n        self.obstacle_threshold = 0.5  # Distance threshold for obstacles\r\n\r\n        self.get_logger().info(\'LIDAR perception node initialized\')\r\n\r\n    def scan_callback(self, msg):\r\n        """Process LIDAR scan data"""\r\n        try:\r\n            # Convert scan to points\r\n            points = self.scan_to_points(msg)\r\n\r\n            # Classify points as obstacles or free space\r\n            obstacles, free_space = self.classify_points(points)\r\n\r\n            # Publish results\r\n            obstacles_cloud = self.create_pointcloud2(obstacles, msg.header)\r\n            free_space_cloud = self.create_pointcloud2(free_space, msg.header)\r\n\r\n            self.obstacle_pub.publish(obstacles_cloud)\r\n            self.free_space_pub.publish(free_space_cloud)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error processing LIDAR scan: {e}\')\r\n\r\n    def scan_to_points(self, scan_msg):\r\n        """Convert LaserScan message to list of 3D points"""\r\n        points = []\r\n        angle = scan_msg.angle_min\r\n\r\n        for i, range_val in enumerate(scan_msg.ranges):\r\n            if self.min_range <= range_val <= self.max_range:\r\n                x = range_val * np.cos(angle)\r\n                y = range_val * np.sin(angle)\r\n                z = 0.0  # Assuming 2D scan\r\n                points.append((x, y, z))\r\n            angle += scan_msg.angle_increment\r\n\r\n        return points\r\n\r\n    def classify_points(self, points):\r\n        """Classify points as obstacles or free space"""\r\n        obstacles = []\r\n        free_space = []\r\n\r\n        for point in points:\r\n            x, y, z = point\r\n            distance = np.sqrt(x**2 + y**2)\r\n\r\n            if distance < self.obstacle_threshold:\r\n                obstacles.append(point)\r\n            else:\r\n                free_space.append(point)\r\n\r\n        return obstacles, free_space\r\n\r\n    def pointcloud_callback(self, msg):\r\n        """Process point cloud data"""\r\n        try:\r\n            # Convert point cloud to numpy array\r\n            points = np.array(list(pc2.read_points(msg, field_names=("x", "y", "z"), skip_nans=True)))\r\n\r\n            # Perform point cloud processing\r\n            processed_points = self.process_pointcloud(points)\r\n\r\n            # Publish results\r\n            processed_cloud = self.create_pointcloud2(processed_points, msg.header)\r\n            self.obstacle_pub.publish(processed_cloud)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error processing point cloud: {e}\')\r\n\r\n    def process_pointcloud(self, points):\r\n        """Process point cloud data"""\r\n        # This could include:\r\n        # - Ground plane removal\r\n        # - Clustering for object detection\r\n        # - Surface normal estimation\r\n        # - Feature extraction\r\n\r\n        # For this example, we\'ll just return the points\r\n        return points\r\n\r\n    def create_pointcloud2(self, points, header):\r\n        """Create PointCloud2 message from list of points"""\r\n        # Convert to list of Point32\r\n        point32_list = [Point32(x=p[0], y=p[1], z=p[2]) for p in points]\r\n\r\n        # Create PointCloud2 message\r\n        cloud_msg = pc2.create_cloud_xyz32(header, point32_list)\r\n        return cloud_msg\n'})}),"\n",(0,s.jsx)(r.h2,{id:"sensor-fusion",children:"Sensor Fusion"}),"\n",(0,s.jsx)(r.h3,{id:"kalman-filter-for-sensor-fusion",children:"Kalman Filter for Sensor Fusion"}),"\n",(0,s.jsx)(r.p,{children:"Kalman filters combine data from multiple sensors optimally:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'import numpy as np\r\nfrom scipy.linalg import block_diag\r\n\r\nclass KalmanFilter:\r\n    def __init__(self, dim_x, dim_z, dim_u=0):\r\n        """Initialize Kalman filter\r\n        dim_x: State dimension\r\n        dim_z: Measurement dimension\r\n        dim_u: Control dimension\r\n        """\r\n        self.dim_x = dim_x\r\n        self.dim_z = dim_z\r\n        self.dim_u = dim_u\r\n\r\n        # State vector [x, y, vx, vy] for 2D tracking\r\n        self.x = np.zeros((dim_x, 1))\r\n\r\n        # State covariance matrix\r\n        self.P = np.eye(dim_x) * 500\r\n\r\n        # Process noise covariance\r\n        self.Q = np.eye(dim_x)\r\n\r\n        # Measurement noise covariance\r\n        self.R = np.eye(dim_z)\r\n\r\n        # State transition matrix (constant velocity model)\r\n        self.F = np.eye(dim_x)\r\n\r\n        # Measurement function\r\n        self.H = np.zeros((dim_z, dim_x))\r\n\r\n        # Control transition matrix\r\n        if dim_u > 0:\r\n            self.B = np.zeros((dim_x, dim_u))\r\n        else:\r\n            self.B = None\r\n\r\n        # Identity matrix for computational efficiency\r\n        self._I = np.eye(dim_x)\r\n\r\n    def predict(self, u=None, B=None, F=None, Q=None):\r\n        """Predict next state"""\r\n        if B is None:\r\n            B = self.B\r\n        if F is None:\r\n            F = self.F\r\n        if Q is None:\r\n            Q = self.Q\r\n        elif np.isscalar(Q):\r\n            Q = np.eye(self.dim_x) * Q\r\n\r\n        # x = Fx + Bu\r\n        if B is not None and u is not None:\r\n            self.x = np.dot(F, self.x) + np.dot(B, u)\r\n        else:\r\n            self.x = np.dot(F, self.x)\r\n\r\n        # P = FPF\' + Q\r\n        self.P = np.dot(np.dot(F, self.P), F.T) + Q\r\n\r\n    def update(self, z, R=None, H=None):\r\n        """Update state with measurement"""\r\n        if z is None:\r\n            return\r\n\r\n        if R is None:\r\n            R = self.R\r\n        elif np.isscalar(R):\r\n            R = np.eye(self.dim_z) * R\r\n\r\n        if H is None:\r\n            H = self.H\r\n\r\n        # Compute residual\r\n        y = z - np.dot(H, self.x)\r\n\r\n        # Compute residual covariance\r\n        PHT = np.dot(self.P, H.T)\r\n        S = np.dot(H, PHT) + R\r\n\r\n        # Compute Kalman gain\r\n        K = np.dot(PHT, np.linalg.inv(S))\r\n\r\n        # Update state\r\n        self.x = self.x + np.dot(K, y)\r\n\r\n        # Update covariance\r\n        I_KH = self._I - np.dot(K, H)\r\n        self.P = np.dot(I_KH, self.P)\r\n\r\nclass SensorFusionNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'sensor_fusion_node\')\r\n\r\n        # Initialize Kalman filter for 2D position and velocity\r\n        # State: [x, y, vx, vy]\r\n        self.kf = KalmanFilter(dim_x=4, dim_z=2)\r\n\r\n        # Initialize filter with constant velocity model\r\n        dt = 0.1  # Time step\r\n        self.kf.F = np.array([\r\n            [1, 0, dt, 0],\r\n            [0, 1, 0, dt],\r\n            [0, 0, 1, 0],\r\n            [0, 0, 0, 1]\r\n        ])\r\n\r\n        # Measurement function (we only measure position)\r\n        self.kf.H = np.array([\r\n            [1, 0, 0, 0],\r\n            [0, 1, 0, 0]\r\n        ])\r\n\r\n        # Process noise (tuned for our application)\r\n        q = 0.1\r\n        self.kf.Q = block_diag(q**2, q**2, q**2, q**2)\r\n\r\n        # Measurement noise\r\n        self.kf.R = np.eye(2) * 0.5**2\r\n\r\n        # Subscribe to different sensors\r\n        self.camera_sub = self.create_subscription(\r\n            Point, \'/camera_detection\', self.camera_callback, 10)\r\n        self.lidar_sub = self.create_subscription(\r\n            Point, \'/lidar_detection\', self.lidar_callback, 10)\r\n        self.odom_sub = self.create_subscription(\r\n            Point, \'/odometry\', self.odom_callback, 10)\r\n\r\n        # Publisher for fused state\r\n        self.state_pub = self.create_publisher(\r\n            Point, \'/fused_state\', 10)\r\n\r\n        # Timer for prediction step\r\n        self.predict_timer = self.create_timer(0.1, self.predict_step)\r\n\r\n        self.get_logger().info(\'Sensor fusion node initialized\')\r\n\r\n    def camera_callback(self, msg):\r\n        """Process camera measurement"""\r\n        # Camera provides position measurement\r\n        z = np.array([[msg.x], [msg.y]])\r\n        self.kf.update(z)\r\n\r\n    def lidar_callback(self, msg):\r\n        """Process LIDAR measurement"""\r\n        # LIDAR provides position measurement\r\n        z = np.array([[msg.x], [msg.y]])\r\n        self.kf.update(z)\r\n\r\n    def odom_callback(self, msg):\r\n        """Process odometry measurement"""\r\n        # Odometry provides position measurement\r\n        z = np.array([[msg.x], [msg.y]])\r\n        self.kf.update(z)\r\n\r\n    def predict_step(self):\r\n        """Prediction step of Kalman filter"""\r\n        self.kf.predict()\r\n\r\n        # Publish current state estimate\r\n        state_msg = Point()\r\n        state_msg.x = float(self.kf.x[0, 0])\r\n        state_msg.y = float(self.kf.x[1, 0])\r\n        state_msg.z = float(self.kf.x[2, 0])  # x velocity\r\n        # Use z field for x velocity in this example\r\n        self.state_pub.publish(state_msg)\n'})}),"\n",(0,s.jsx)(r.h3,{id:"particle-filter-for-non-linear-systems",children:"Particle Filter for Non-linear Systems"}),"\n",(0,s.jsx)(r.p,{children:"For non-linear systems, particle filters can be more appropriate:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'class ParticleFilter:\r\n    def __init__(self, num_particles, state_dim, process_noise, measurement_noise):\r\n        self.num_particles = num_particles\r\n        self.state_dim = state_dim\r\n        self.process_noise = process_noise\r\n        self.measurement_noise = measurement_noise\r\n\r\n        # Initialize particles randomly\r\n        self.particles = np.random.randn(num_particles, state_dim) * 10\r\n        self.weights = np.ones(num_particles) / num_particles\r\n\r\n    def predict(self, control_input=None):\r\n        """Predict step: propagate particles through motion model"""\r\n        for i in range(self.num_particles):\r\n            # Simple motion model (constant velocity with noise)\r\n            self.particles[i] += np.random.normal(0, self.process_noise, self.state_dim)\r\n\r\n    def update(self, measurement):\r\n        """Update step: adjust weights based on measurement likelihood"""\r\n        # Calculate likelihood of each particle given measurement\r\n        for i in range(self.num_particles):\r\n            # Calculate distance between particle and measurement\r\n            distance = np.linalg.norm(self.particles[i] - measurement)\r\n            # Update weight based on likelihood (Gaussian model)\r\n            likelihood = np.exp(-0.5 * (distance**2) / (self.measurement_noise**2))\r\n            self.weights[i] *= likelihood\r\n\r\n        # Normalize weights\r\n        self.weights += 1.e-300  # Avoid zero weights\r\n        self.weights /= np.sum(self.weights)\r\n\r\n    def resample(self):\r\n        """Resample particles based on their weights"""\r\n        # Systematic resampling\r\n        indices = []\r\n        step = 1.0 / self.num_particles\r\n        start = np.random.uniform(0, step)\r\n\r\n        i = 0\r\n        for j in range(self.num_particles):\r\n            while start > self.weights[i]:\r\n                start -= self.weights[i]\r\n                i += 1\r\n            indices.append(i)\r\n\r\n        # Resample particles\r\n        self.particles = self.particles[indices]\r\n        self.weights = np.ones(self.num_particles) / self.num_particles\r\n\r\n    def estimate(self):\r\n        """Get state estimate as weighted average of particles"""\r\n        return np.average(self.particles, weights=self.weights, axis=0)\r\n\r\nclass ParticleFilterNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'particle_filter_node\')\r\n\r\n        # Initialize particle filter\r\n        self.pf = ParticleFilter(\r\n            num_particles=100,\r\n            state_dim=2,  # 2D position\r\n            process_noise=0.1,\r\n            measurement_noise=0.5\r\n        )\r\n\r\n        # Subscribe to sensor measurements\r\n        self.measurement_sub = self.create_subscription(\r\n            Point, \'/sensor_measurement\', self.measurement_callback, 10)\r\n\r\n        # Publisher for estimated state\r\n        self.estimate_pub = self.create_publisher(\r\n            Point, \'/particle_filter_estimate\', 10)\r\n\r\n        # Timer for prediction step\r\n        self.predict_timer = self.create_timer(0.1, self.predict_step)\r\n\r\n        self.get_logger().info(\'Particle filter node initialized\')\r\n\r\n    def measurement_callback(self, msg):\r\n        """Process measurement and update filter"""\r\n        measurement = np.array([msg.x, msg.y])\r\n        self.pf.update(measurement)\r\n        self.pf.resample()\r\n\r\n    def predict_step(self):\r\n        """Prediction step"""\r\n        self.pf.predict()\r\n\r\n        # Get and publish estimate\r\n        estimate = self.pf.estimate()\r\n        estimate_msg = Point()\r\n        estimate_msg.x = float(estimate[0])\r\n        estimate_msg.y = float(estimate[1])\r\n        estimate_msg.z = 0.0  # Not used in this example\r\n        self.estimate_pub.publish(estimate_msg)\n'})}),"\n",(0,s.jsx)(r.h2,{id:"slam-simultaneous-localization-and-mapping",children:"SLAM (Simultaneous Localization and Mapping)"}),"\n",(0,s.jsx)(r.h3,{id:"visual-slam",children:"Visual SLAM"}),"\n",(0,s.jsx)(r.p,{children:"Visual SLAM systems build maps while localizing:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'class VisualSLAMNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'visual_slam_node\')\r\n\r\n        # Initialize CV bridge\r\n        self.cv_bridge = CvBridge()\r\n\r\n        # Create subscriber for camera images\r\n        self.image_sub = self.create_subscription(\r\n            Image, \'/camera/image_raw\', self.image_callback, 10)\r\n\r\n        # Create publisher for map visualization\r\n        self.map_pub = self.create_publisher(\r\n            MarkerArray, \'/slam_map\', 10)\r\n\r\n        # SLAM parameters\r\n        self.keyframe_threshold = 10  # Threshold for keyframe selection\r\n        self.max_features = 1000      # Maximum features to track\r\n\r\n        # Initialize ORB detector and descriptor\r\n        self.orb = cv2.ORB_create(nfeatures=self.max_features)\r\n\r\n        # FLANN matcher for feature matching\r\n        FLANN_INDEX_LSH = 6\r\n        index_params = dict(algorithm=FLANN_INDEX_LSH, table_number=6, key_size=12, multi_probe_level=1)\r\n        search_params = dict(checks=50)\r\n        self.flann = cv2.FlannBasedMatcher(index_params, search_params)\r\n\r\n        # SLAM state\r\n        self.current_frame = None\r\n        self.keyframes = []\r\n        self.map_points = []\r\n        self.current_pose = np.eye(4)  # 4x4 identity matrix\r\n\r\n        self.get_logger().info(\'Visual SLAM node initialized\')\r\n\r\n    def image_callback(self, msg):\r\n        """Process image for SLAM"""\r\n        try:\r\n            cv_image = self.cv_bridge.imgmsg_to_cv2(msg, "bgr8")\r\n\r\n            # Extract features from current image\r\n            keypoints, descriptors = self.extract_features(cv_image)\r\n\r\n            if len(self.keyframes) == 0:\r\n                # First frame - initialize\r\n                self.keyframes.append({\r\n                    \'image\': cv_image,\r\n                    \'keypoints\': keypoints,\r\n                    \'descriptors\': descriptors,\r\n                    \'pose\': self.current_pose.copy()\r\n                })\r\n            else:\r\n                # Track features and estimate motion\r\n                prev_frame = self.keyframes[-1]\r\n                matches = self.match_features(prev_frame[\'descriptors\'], descriptors)\r\n\r\n                if len(matches) > 10:  # Minimum matches for reliable pose estimation\r\n                    # Estimate relative pose\r\n                    pose_change = self.estimate_pose(\r\n                        prev_frame[\'keypoints\'], keypoints, matches\r\n                    )\r\n\r\n                    # Update current pose\r\n                    self.current_pose = self.current_pose @ pose_change\r\n\r\n                    # Add as keyframe if significant motion\r\n                    if self.should_add_keyframe():\r\n                        self.keyframes.append({\r\n                            \'image\': cv_image,\r\n                            \'keypoints\': keypoints,\r\n                            \'descriptors\': descriptors,\r\n                            \'pose\': self.current_pose.copy()\r\n                        })\r\n\r\n                        # Update map points\r\n                        self.update_map_points(keypoints, matches)\r\n\r\n            # Publish map visualization\r\n            self.publish_map_visualization(msg.header)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error in SLAM: {e}\')\r\n\r\n    def extract_features(self, image):\r\n        """Extract ORB features from image"""\r\n        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\r\n        keypoints, descriptors = self.orb.detectAndCompute(gray, None)\r\n        return keypoints, descriptors\r\n\r\n    def match_features(self, desc1, desc2):\r\n        """Match features between two descriptors"""\r\n        if desc1 is None or desc2 is None:\r\n            return []\r\n\r\n        try:\r\n            matches = self.flann.knnMatch(desc1, desc2, k=2)\r\n            # Apply Lowe\'s ratio test\r\n            good_matches = []\r\n            for match_pair in matches:\r\n                if len(match_pair) == 2:\r\n                    m, n = match_pair\r\n                    if m.distance < 0.7 * n.distance:\r\n                        good_matches.append(m)\r\n            return good_matches\r\n        except:\r\n            return []\r\n\r\n    def estimate_pose(self, kp1, kp2, matches):\r\n        """Estimate relative pose from matched keypoints"""\r\n        if len(matches) >= 4:\r\n            # Get matched points\r\n            src_pts = np.float32([kp1[m.queryIdx].pt for m in matches]).reshape(-1, 1, 2)\r\n            dst_pts = np.float32([kp2[m.trainIdx].pt for m in matches]).reshape(-1, 1, 2)\r\n\r\n            # Find fundamental matrix\r\n            F, mask = cv2.findFundamentalMat(src_pts, dst_pts, cv2.RANSAC, 4, 0.999)\r\n\r\n            # For simplicity, we\'ll return a simple transformation\r\n            # In a real system, this would involve more complex pose estimation\r\n            return np.eye(4)  # Placeholder\r\n        else:\r\n            return np.eye(4)\r\n\r\n    def should_add_keyframe(self):\r\n        """Determine if current frame should be added as keyframe"""\r\n        # Simple criterion: add keyframe if we have enough new features\r\n        # or if enough time has passed\r\n        return len(self.keyframes) % self.keyframe_threshold == 0\r\n\r\n    def update_map_points(self, keypoints, matches):\r\n        """Update map points based on current observations"""\r\n        # This would triangulate 3D points from stereo observations\r\n        # or track points across frames\r\n        pass\r\n\r\n    def publish_map_visualization(self, header):\r\n        """Publish map visualization markers"""\r\n        marker_array = MarkerArray()\r\n\r\n        # Create markers for keyframe positions\r\n        for i, kf in enumerate(self.keyframes):\r\n            marker = Marker()\r\n            marker.header = header\r\n            marker.ns = "keyframes"\r\n            marker.id = i\r\n            marker.type = Marker.CUBE\r\n            marker.action = Marker.ADD\r\n\r\n            # Position from pose\r\n            marker.pose.position.x = kf[\'pose\'][0, 3] / 10  # Scale down for visualization\r\n            marker.pose.position.y = kf[\'pose\'][1, 3] / 10\r\n            marker.pose.position.z = kf[\'pose\'][2, 3] / 10\r\n            marker.pose.orientation.w = 1.0\r\n\r\n            # Scale\r\n            marker.scale.x = 0.1\r\n            marker.scale.y = 0.1\r\n            marker.scale.z = 0.1\r\n\r\n            # Color (blue)\r\n            marker.color.b = 1.0\r\n            marker.color.a = 1.0\r\n\r\n            marker_array.markers.append(marker)\r\n\r\n        self.map_pub.publish(marker_array)\n'})}),"\n",(0,s.jsx)(r.h2,{id:"hardware-specific-optimizations",children:"Hardware-Specific Optimizations"}),"\n",(0,s.jsx)(r.h3,{id:"for-nvidia-jetson-users",children:"For NVIDIA Jetson Users"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'# Jetson-specific perception optimizations\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nimport numpy as np\r\n\r\nclass JetsonPerceptionNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'jetson_perception_node\')\r\n\r\n        # Optimize perception for Jetson\'s ARM architecture and GPU\r\n        self.setup_jetson_optimizations()\r\n\r\n        self.get_logger().info(\'Jetson-optimized perception node initialized\')\r\n\r\n    def setup_jetson_optimizations(self):\r\n        """Configure perception for Jetson hardware"""\r\n        # Use optimized libraries for Jetson\r\n        # Adjust algorithm parameters for Jetson\'s capabilities\r\n        # Enable hardware acceleration where possible\r\n        # Optimized for [USER_GPU] hardware\r\n        pass\r\n\r\n    def jetson_image_processing(self, image):\r\n        """\r\n        Process image using Jetson-optimized methods\r\n        Optimized for [USER_GPU] hardware\r\n        """\r\n        # Use Jetson\'s hardware accelerators for image processing\r\n        # This would leverage Jetson\'s ISP, GPU, and other processing units\r\n        pass\n'})}),"\n",(0,s.jsx)(r.h3,{id:"for-high-end-gpu-users",children:"For High-End GPU Users"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'# High-end GPU perception optimizations\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nimport torch\r\nimport numpy as np\r\n\r\nclass GPUOptimizedPerceptionNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'gpu_optimized_perception_node\')\r\n\r\n        # Initialize GPU context for perception\r\n        self.device = torch.device(\'cuda\' if torch.cuda.is_available() else \'cpu\')\r\n\r\n        # Configure perception for high-end GPU\r\n        self.setup_gpu_optimizations()\r\n\r\n        self.get_logger().info(\'GPU-optimized perception node initialized\')\r\n\r\n    def setup_gpu_optimizations(self):\r\n        """Configure perception for high-end GPU hardware"""\r\n        # Set environment variables for GPU optimization\r\n        # Enable advanced perception features for powerful GPUs\r\n        # Use multi-GPU processing if available\r\n        # Optimized for [USER_GPU] hardware specifications\r\n        pass\r\n\r\n    def gpu_accelerated_perception(self, sensor_data):\r\n        """\r\n        Perform GPU-accelerated perception processing\r\n        Optimized for [USER_GPU] hardware specifications\r\n        """\r\n        # Use GPU for intensive perception computations\r\n        # Leverage tensor cores for efficient parallel computation\r\n        # Implement batch processing for efficiency\r\n        pass\n'})}),"\n",(0,s.jsx)(r.h2,{id:"3d-perception-and-reconstruction",children:"3D Perception and Reconstruction"}),"\n",(0,s.jsx)(r.h3,{id:"point-cloud-processing",children:"Point Cloud Processing"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'from sensor_msgs.msg import PointCloud2\r\nimport sensor_msgs.point_cloud2 as pc2\r\nfrom geometry_msgs.msg import Point\r\nfrom std_msgs.msg import Header\r\n\r\nclass PointCloudPerceptionNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'pointcloud_perception_node\')\r\n\r\n        # Subscribe to point cloud\r\n        self.pc_sub = self.create_subscription(\r\n            PointCloud2, \'/points\', self.pointcloud_callback, 10)\r\n\r\n        # Publishers for processed data\r\n        self.ground_pub = self.create_publisher(\r\n            PointCloud2, \'/ground_points\', 10)\r\n        self.obstacles_pub = self.create_publisher(\r\n            PointCloud2, \'/obstacle_points\', 10)\r\n\r\n        # RANSAC parameters for ground plane detection\r\n        self.ransac_max_iterations = 100\r\n        self.ransac_distance_threshold = 0.1\r\n\r\n        self.get_logger().info(\'Point cloud perception node initialized\')\r\n\r\n    def pointcloud_callback(self, msg):\r\n        """Process point cloud data"""\r\n        try:\r\n            # Convert PointCloud2 to numpy array\r\n            points = np.array(list(pc2.read_points(msg, field_names=("x", "y", "z"), skip_nans=True)))\r\n\r\n            if len(points) > 0:\r\n                # Separate ground and obstacles using RANSAC\r\n                ground_points, obstacle_points = self.separate_ground_obstacles(points)\r\n\r\n                # Publish results\r\n                if len(ground_points) > 0:\r\n                    ground_cloud = self.create_pointcloud2(ground_points, msg.header)\r\n                    self.ground_pub.publish(ground_cloud)\r\n\r\n                if len(obstacle_points) > 0:\r\n                    obstacle_cloud = self.create_pointcloud2(obstacle_points, msg.header)\r\n                    self.obstacles_pub.publish(obstacle_cloud)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error processing point cloud: {e}\')\r\n\r\n    def separate_ground_obstacles(self, points):\r\n        """Separate ground and obstacle points using RANSAC"""\r\n        if len(points) < 3:\r\n            return np.array([]), points\r\n\r\n        best_model = None\r\n        best_inliers = []\r\n        best_error = float(\'inf\')\r\n\r\n        # RANSAC for plane fitting (ground plane)\r\n        for _ in range(self.ransac_max_iterations):\r\n            # Randomly select 3 points\r\n            indices = np.random.choice(len(points), 3, replace=False)\r\n            sample_points = points[indices]\r\n\r\n            # Fit plane to these points\r\n            model = self.fit_plane(sample_points)\r\n\r\n            if model is not None:\r\n                # Calculate distances to plane\r\n                distances = np.abs(np.dot(points, model[:3]) + model[3])\r\n                inliers = points[distances < self.ransac_distance_threshold]\r\n\r\n                if len(inliers) > len(best_inliers):\r\n                    best_model = model\r\n                    best_inliers = inliers\r\n                    best_error = np.mean(distances[distances < self.ransac_distance_threshold])\r\n\r\n        # If we found a good ground plane\r\n        if best_model is not None and len(best_inliers) > len(points) * 0.1:  # At least 10% of points\r\n            # Calculate distances to the best plane\r\n            all_distances = np.abs(np.dot(points, best_model[:3]) + best_model[3])\r\n            ground_mask = all_distances < self.ransac_distance_threshold\r\n\r\n            ground_points = points[ground_mask]\r\n            obstacle_points = points[~ground_mask]\r\n        else:\r\n            # If no good ground plane found, assume no ground separation\r\n            ground_points = np.array([])\r\n            obstacle_points = points\r\n\r\n        return ground_points, obstacle_points\r\n\r\n    def fit_plane(self, points):\r\n        """Fit a plane to 3D points using SVD"""\r\n        if len(points) < 3:\r\n            return None\r\n\r\n        # Calculate centroid\r\n        centroid = np.mean(points, axis=0)\r\n\r\n        # Center points\r\n        centered_points = points - centroid\r\n\r\n        # Calculate covariance matrix\r\n        cov_matrix = np.cov(centered_points.T)\r\n\r\n        # Calculate SVD\r\n        u, s, vh = np.linalg.svd(cov_matrix)\r\n\r\n        # Normal vector is the eigenvector with smallest eigenvalue\r\n        normal = vh[2, :]\r\n\r\n        # Calculate d parameter: ax + by + cz + d = 0\r\n        d = -np.dot(normal, centroid)\r\n\r\n        return np.array([normal[0], normal[1], normal[2], d])\r\n\r\n    def create_pointcloud2(self, points, header):\r\n        """Create PointCloud2 message from numpy array"""\r\n        # Convert numpy array to list of Point32\r\n        point32_list = [Point32(x=p[0], y=p[1], z=p[2]) for p in points]\r\n\r\n        # Create PointCloud2 message\r\n        cloud_msg = pc2.create_cloud_xyz32(header, point32_list)\r\n        return cloud_msg\n'})}),"\n",(0,s.jsx)(r.h2,{id:"perception-quality-assessment",children:"Perception Quality Assessment"}),"\n",(0,s.jsx)(r.h3,{id:"performance-metrics",children:"Performance Metrics"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"class PerceptionQualityNode(Node):\r\n    def __init__(self):\r\n        super().__init__('perception_quality_node')\r\n\r\n        # Publishers for quality metrics\r\n        self.quality_pub = self.create_publisher(\r\n            Float64MultiArray, '/perception_quality', 10)\r\n\r\n        # Quality assessment parameters\r\n        self.confidence_threshold = 0.5\r\n        self.min_detection_count = 5\r\n\r\n        # Store metrics over time\r\n        self.detection_confidences = []\r\n        self.detection_rates = []\r\n\r\n        # Timer for quality assessment\r\n        self.quality_timer = self.create_timer(1.0, self.assess_quality)\r\n\r\n        self.get_logger().info('Perception quality assessment node initialized')\r\n\r\n    def assess_quality(self):\r\n        \"\"\"Assess perception system quality\"\"\"\r\n        if len(self.detection_confidences) == 0:\r\n            return\r\n\r\n        # Calculate quality metrics\r\n        avg_confidence = np.mean(self.detection_confidences)\r\n        confidence_std = np.std(self.detection_confidences)\r\n        detection_rate = len([c for c in self.detection_confidences if c > self.confidence_threshold]) / len(self.detection_confidences)\r\n\r\n        # Prepare quality report\r\n        quality_metrics = [\r\n            float(avg_confidence),\r\n            float(confidence_std),\r\n            float(detection_rate),\r\n            float(len(self.detection_confidences))\r\n        ]\r\n\r\n        # Publish quality metrics\r\n        quality_msg = Float64MultiArray()\r\n        quality_msg.data = quality_metrics\r\n        self.quality_pub.publish(quality_msg)\r\n\r\n        # Log quality assessment\r\n        self.get_logger().info(\r\n            f'Perception Quality - Avg Confidence: {avg_confidence:.3f}, '\r\n            f'Detection Rate: {detection_rate:.3f}, '\r\n            f'Count: {len(self.detection_confidences)}'\r\n        )\r\n\r\n        # Clear metrics for next assessment\r\n        self.detection_confidences.clear()\n"})}),"\n",(0,s.jsx)(r.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Multi-sensor Integration"}),": Effective perception combines data from multiple sensors for robustness."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Real-time Processing"}),": Perception systems must operate within strict timing constraints for robot control."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Uncertainty Management"}),": All perception results have associated uncertainties that must be handled properly."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Hardware Optimization"}),": Different optimization strategies are needed for different hardware platforms."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"SLAM"}),": Simultaneous Localization and Mapping is essential for autonomous navigation in unknown environments."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Quality Assessment"}),": Perception systems need continuous quality monitoring and assessment."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"3D Understanding"}),": Modern robots require 3D scene understanding for manipulation and navigation."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"practice-exercises",children:"Practice Exercises"}),"\n",(0,s.jsx)(r.h3,{id:"exercise-1-feature-detection",children:"Exercise 1: Feature Detection"}),"\n",(0,s.jsx)(r.p,{children:"Implement a feature detection system that can detect and match features between consecutive camera frames."}),"\n",(0,s.jsx)(r.h3,{id:"exercise-2-sensor-fusion",children:"Exercise 2: Sensor Fusion"}),"\n",(0,s.jsx)(r.p,{children:"Create a sensor fusion system that combines camera and LIDAR data to improve object detection accuracy."}),"\n",(0,s.jsx)(r.h3,{id:"exercise-3-slam-implementation",children:"Exercise 3: SLAM Implementation"}),"\n",(0,s.jsx)(r.p,{children:"Implement a basic visual SLAM system that can build a map while tracking the robot's position."}),"\n",(0,s.jsx)(r.h3,{id:"exercise-4-3d-reconstruction",children:"Exercise 4: 3D Reconstruction"}),"\n",(0,s.jsx)(r.p,{children:"Create a system that reconstructs 3D scenes from stereo camera images or LIDAR data."}),"\n",(0,s.jsx)(r.h3,{id:"exercise-5-hardware-optimization",children:"Exercise 5: Hardware Optimization"}),"\n",(0,s.jsx)(r.p,{children:"Optimize a perception algorithm for your specific hardware configuration (GPU/Jetson) and measure performance improvements."}),"\n",(0,s.jsx)(r.h2,{id:"mcqs-quiz",children:"MCQs Quiz"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"What does SLAM stand for in robotics?"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"A) Simultaneous Localization and Mapping"}),"\n",(0,s.jsx)(r.li,{children:"B) Sensor Localization and Mapping"}),"\n",(0,s.jsx)(r.li,{children:"C) Stereo Localization and Mapping"}),"\n",(0,s.jsx)(r.li,{children:"D) Systematic Localization and Mapping"}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.strong,{children:"Answer: A"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"Which sensor provides the most accurate depth information for close-range perception?"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"A) Camera"}),"\n",(0,s.jsx)(r.li,{children:"B) LIDAR"}),"\n",(0,s.jsx)(r.li,{children:"C) Ultrasonic sensor"}),"\n",(0,s.jsx)(r.li,{children:"D) Infrared sensor"}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.strong,{children:"Answer: B"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"What is the primary purpose of sensor fusion in perception systems?"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"A) To reduce cost only"}),"\n",(0,s.jsx)(r.li,{children:"B) To combine data from multiple sensors for robust perception"}),"\n",(0,s.jsx)(r.li,{children:"C) To increase sensor range"}),"\n",(0,s.jsx)(r.li,{children:"D) To eliminate the need for calibration"}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.strong,{children:"Answer: B"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"Which feature detector is known for being scale-invariant?"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"A) Harris corner detector"}),"\n",(0,s.jsx)(r.li,{children:"B) SIFT (Scale-Invariant Feature Transform)"}),"\n",(0,s.jsx)(r.li,{children:"C) Canny edge detector"}),"\n",(0,s.jsx)(r.li,{children:"D) Sobel operator"}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.strong,{children:"Answer: B"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"What is a key advantage of using a particle filter over a Kalman filter?"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"A) Lower computational cost"}),"\n",(0,s.jsx)(r.li,{children:"B) Better performance with non-linear systems and non-Gaussian noise"}),"\n",(0,s.jsx)(r.li,{children:"C) Guaranteed convergence"}),"\n",(0,s.jsx)(r.li,{children:"D) Simpler implementation"}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.strong,{children:"Answer: B"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:'"Computer Vision: Algorithms and Applications" by Richard Szeliski'}),"\n",(0,s.jsx)(r.li,{children:'"Probabilistic Robotics" by Thrun, Burgard, and Fox'}),"\n",(0,s.jsx)(r.li,{children:'"Multiple View Geometry in Computer Vision" by Hartley and Zisserman'}),"\n",(0,s.jsx)(r.li,{children:'"Learning OpenCV" by Bradski and Kaehler'}),"\n",(0,s.jsxs)(r.li,{children:["Point Cloud Library (PCL): ",(0,s.jsx)(r.a,{href:"http://pointclouds.org/",children:"http://pointclouds.org/"})]}),"\n",(0,s.jsxs)(r.li,{children:["ROS Perception: ",(0,s.jsx)(r.a,{href:"http://wiki.ros.org/perception",children:"http://wiki.ros.org/perception"})]}),"\n",(0,s.jsxs)(r.li,{children:["OpenCV Documentation: ",(0,s.jsx)(r.a,{href:"https://docs.opencv.org/",children:"https://docs.opencv.org/"})]}),"\n",(0,s.jsx)(r.li,{children:'"Visual SLAM: Why Bundle Adjust?" - Recent advances in SLAM research'}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.em,{children:"Generated with reusable Claude Subagents & Spec-Kit Plus"})})]})}function p(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>o});var s=n(6540);const i={},t=s.createContext(i);function a(e){const r=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:r},e.children)}}}]);