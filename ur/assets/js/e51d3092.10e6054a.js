"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[770],{4876:(n,r,e)=>{e.r(r),e.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var t=e(4848),o=e(8453);const i={sidebar_position:8,title:"Motion Planning & Control",description:"Algorithms for trajectory generation and robot control",slug:"/motion-planning"},a="Motion Planning & Control",s={id:"motion-planning/index",title:"Motion Planning & Control",description:"Algorithms for trajectory generation and robot control",source:"@site/docs/motion-planning/index.mdx",sourceDirName:"motion-planning",slug:"/motion-planning",permalink:"/Humanoid-Robotic-Book/ur/docs/motion-planning",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/motion-planning/index.mdx",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8,title:"Motion Planning & Control",description:"Algorithms for trajectory generation and robot control",slug:"/motion-planning"},sidebar:"tutorialSidebar",previous:{title:"Hardware Integration",permalink:"/Humanoid-Robotic-Book/ur/docs/hardware-integration"},next:{title:"Perception Systems",permalink:"/Humanoid-Robotic-Book/ur/docs/perception"}},l={},c=[{value:"Introduction to Motion Planning and Control",id:"introduction-to-motion-planning-and-control",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Path Planning Algorithms",id:"path-planning-algorithms",level:2},{value:"Sampling-Based Methods",id:"sampling-based-methods",level:3},{value:"RRT (Rapidly-exploring Random Tree)",id:"rrt-rapidly-exploring-random-tree",level:4},{value:"RRT*",id:"rrt",level:4},{value:"Search-Based Methods",id:"search-based-methods",level:3},{value:"A* Algorithm",id:"a-algorithm",level:4},{value:"Trajectory Generation",id:"trajectory-generation",level:2},{value:"Polynomial Trajectories",id:"polynomial-trajectories",level:3},{value:"B-Spline Trajectories",id:"b-spline-trajectories",level:3},{value:"Motion Control",id:"motion-control",level:2},{value:"PID Control",id:"pid-control",level:3},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:3},{value:"Advanced Control Techniques",id:"advanced-control-techniques",level:3},{value:"Impedance Control",id:"impedance-control",level:4},{value:"Integration with ROS 2 Navigation",id:"integration-with-ros-2-navigation",level:2},{value:"Custom Trajectory Controller",id:"custom-trajectory-controller",level:3},{value:"Hardware-Specific Optimizations",id:"hardware-specific-optimizations",level:2},{value:"For NVIDIA Jetson Users",id:"for-nvidia-jetson-users",level:3},{value:"For High-End GPU Users",id:"for-high-end-gpu-users",level:3},{value:"Real-time Considerations",id:"real-time-considerations",level:2},{value:"Control Loop Timing",id:"control-loop-timing",level:3},{value:"Safety and Validation",id:"safety-and-validation",level:2},{value:"Trajectory Validation",id:"trajectory-validation",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Practice Exercises",id:"practice-exercises",level:2},{value:"Exercise 1: Basic Path Planning",id:"exercise-1-basic-path-planning",level:3},{value:"Exercise 2: Trajectory Generation",id:"exercise-2-trajectory-generation",level:3},{value:"Exercise 3: PID Control",id:"exercise-3-pid-control",level:3},{value:"Exercise 4: Obstacle Avoidance",id:"exercise-4-obstacle-avoidance",level:3},{value:"Exercise 5: Hardware Optimization",id:"exercise-5-hardware-optimization",level:3},{value:"MCQs Quiz",id:"mcqs-quiz",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(n){const r={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{id:"motion-planning--control",children:"Motion Planning & Control"}),"\n",(0,t.jsx)(r.h2,{id:"introduction-to-motion-planning-and-control",children:"Introduction to Motion Planning and Control"}),"\n",(0,t.jsx)(r.p,{children:"Motion planning and control form the backbone of autonomous robotic systems, enabling robots to navigate complex environments, avoid obstacles, and execute precise movements. This field encompasses algorithms for path planning, trajectory generation, and real-time control that ensure robots can safely and efficiently reach their goals while respecting dynamic constraints."}),"\n",(0,t.jsx)(r.h3,{id:"core-components",children:"Core Components"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Path Planning"}),": Finding collision-free paths from start to goal"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Trajectory Generation"}),": Creating time-parameterized paths with velocity and acceleration profiles"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Motion Control"}),": Executing trajectories while handling disturbances and uncertainties"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Feedback Control"}),": Adjusting motion based on sensor feedback"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Dynamic Modeling"}),": Understanding robot dynamics for accurate control"]}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-mermaid",children:"graph TD\r\n    A[Motion Planning & Control] --\x3e B[Path Planning]\r\n    A --\x3e C[Trajectory Generation]\r\n    A --\x3e D[Motion Control]\r\n    A --\x3e E[State Estimation]\r\n\r\n    B --\x3e B1[Sampling-based: RRT*, PRM]\r\n    B --\x3e B2[Search-based: A*, D*]\r\n    B --\x3e B3[Optimization-based: CHOMP, STOMP]\r\n\r\n    C --\x3e C1[Polynomial Trajectories]\r\n    C --\x3e C2[B-Splines]\r\n    C --\x3e C3[Minimum Jerk Paths]\r\n\r\n    D --\x3e D1[PID Control]\r\n    D --\x3e D2[Model Predictive Control]\r\n    D --\x3e D3[Impedance Control]\r\n\r\n    E --\x3e E1[Extended Kalman Filter]\r\n    E --\x3e E2[Particle Filter]\r\n    E --\x3e E3[Complementary Filter]\n"})}),"\n",(0,t.jsx)(r.h2,{id:"path-planning-algorithms",children:"Path Planning Algorithms"}),"\n",(0,t.jsx)(r.h3,{id:"sampling-based-methods",children:"Sampling-Based Methods"}),"\n",(0,t.jsx)(r.p,{children:"Sampling-based methods explore the configuration space by randomly sampling points and connecting them to form a roadmap or tree structure."}),"\n",(0,t.jsx)(r.h4,{id:"rrt-rapidly-exploring-random-tree",children:"RRT (Rapidly-exploring Random Tree)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'import numpy as np\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Point, Pose, PoseStamped\r\nfrom nav_msgs.msg import Path\r\nfrom visualization_msgs.msg import Marker, MarkerArray\r\nimport random\r\nfrom scipy.spatial import KDTree\r\n\r\nclass RRTNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'rrt_planner\')\r\n\r\n        # Create publisher for path\r\n        self.path_pub = self.create_publisher(Path, \'/rrt_path\', 10)\r\n\r\n        # Create publisher for visualization\r\n        self.vis_pub = self.create_publisher(MarkerArray, \'/rrt_visualization\', 10)\r\n\r\n        # Initialize RRT parameters\r\n        self.max_iterations = 1000\r\n        self.step_size = 0.1\r\n        self.goal_bias = 0.1\r\n\r\n        # Define environment bounds\r\n        self.x_min, self.x_max = -10.0, 10.0\r\n        self.y_min, self.y_max = -10.0, 10.0\r\n\r\n        # Define obstacles (simplified for this example)\r\n        self.obstacles = [\r\n            {\'center\': np.array([2.0, 2.0]), \'radius\': 1.0},\r\n            {\'center\': np.array([-2.0, -2.0]), \'radius\': 1.0},\r\n        ]\r\n\r\n    def plan_path(self, start, goal):\r\n        """\r\n        Plan path using RRT algorithm\r\n        Optimized for [USER_GPU] hardware\r\n        """\r\n        # Initialize tree with start node\r\n        tree = [start]\r\n        parent_map = {tuple(start): None}\r\n\r\n        for iteration in range(self.max_iterations):\r\n            # Sample random point (with goal bias)\r\n            if random.random() < self.goal_bias:\r\n                rand_point = goal\r\n            else:\r\n                rand_point = np.array([\r\n                    random.uniform(self.x_min, self.x_max),\r\n                    random.uniform(self.y_min, self.y_max)\r\n                ])\r\n\r\n            # Find nearest node in tree\r\n            nearest_idx = self.find_nearest_node(tree, rand_point)\r\n            nearest_node = tree[nearest_idx]\r\n\r\n            # Generate new node in direction of random point\r\n            new_node = self.steer(nearest_node, rand_point)\r\n\r\n            # Check if path is collision-free\r\n            if self.is_collision_free(nearest_node, new_node):\r\n                tree.append(new_node)\r\n                parent_map[tuple(new_node)] = tuple(nearest_node)\r\n\r\n                # Check if goal is reached\r\n                if np.linalg.norm(new_node - goal) < self.step_size:\r\n                    path = self.reconstruct_path(parent_map, tuple(start), tuple(new_node))\r\n                    return path\r\n\r\n        # If no path found, return empty path\r\n        return []\r\n\r\n    def find_nearest_node(self, tree, point):\r\n        """Find nearest node in tree to given point"""\r\n        min_dist = float(\'inf\')\r\n        nearest_idx = 0\r\n\r\n        for i, node in enumerate(tree):\r\n            dist = np.linalg.norm(node - point)\r\n            if dist < min_dist:\r\n                min_dist = dist\r\n                nearest_idx = i\r\n\r\n        return nearest_idx\r\n\r\n    def steer(self, from_node, to_node):\r\n        """Generate new node in direction of to_node from from_node"""\r\n        direction = to_node - from_node\r\n        distance = np.linalg.norm(direction)\r\n\r\n        if distance <= self.step_size:\r\n            return to_node\r\n        else:\r\n            normalized_direction = direction / distance\r\n            new_node = from_node + normalized_direction * self.step_size\r\n            return new_node\r\n\r\n    def is_collision_free(self, node1, node2):\r\n        """Check if path between two nodes is collision-free"""\r\n        # Simple line collision check\r\n        num_samples = int(np.linalg.norm(node2 - node1) / 0.1) + 1\r\n        for i in range(num_samples + 1):\r\n            t = i / num_samples\r\n            point = (1 - t) * node1 + t * node2\r\n\r\n            if self.is_in_collision(point):\r\n                return False\r\n\r\n        return True\r\n\r\n    def is_in_collision(self, point):\r\n        """Check if point is in collision with obstacles"""\r\n        for obstacle in self.obstacles:\r\n            dist_to_center = np.linalg.norm(point - obstacle[\'center\'])\r\n            if dist_to_center < obstacle[\'radius\']:\r\n                return True\r\n        return False\r\n\r\n    def reconstruct_path(self, parent_map, start, goal):\r\n        """Reconstruct path from parent map"""\r\n        path = []\r\n        current = goal\r\n\r\n        while current is not None:\r\n            path.append(np.array(current))\r\n            current = parent_map[current]\r\n\r\n        path.reverse()\r\n        return path\n'})}),"\n",(0,t.jsx)(r.h4,{id:"rrt",children:"RRT*"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'class RRTStarNode(RRTNode):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.rewire_radius = 1.5  # Radius for rewiring\r\n\r\n    def plan_path(self, start, goal):\r\n        """\r\n        Plan path using RRT* algorithm for optimal solutions\r\n        Optimized for [USER_GPU] hardware\r\n        """\r\n        tree = [start]\r\n        parent_map = {tuple(start): None}\r\n        cost_map = {tuple(start): 0.0}\r\n\r\n        for iteration in range(self.max_iterations):\r\n            # Sample random point (with goal bias)\r\n            if random.random() < self.goal_bias:\r\n                rand_point = goal\r\n            else:\r\n                rand_point = self.sample_free_space()\r\n\r\n            # Find nearest node\r\n            nearest_idx = self.find_nearest_node(tree, rand_point)\r\n            nearest_node = tree[nearest_idx]\r\n\r\n            # Generate new node\r\n            new_node = self.steer(nearest_node, rand_point)\r\n\r\n            # Check collision\r\n            if not self.is_collision_free(nearest_node, new_node):\r\n                continue\r\n\r\n            # Find neighbors within rewire radius\r\n            neighbors = self.find_neighbors(tree, new_node, self.rewire_radius)\r\n\r\n            # Choose parent with minimum cost\r\n            min_cost = float(\'inf\')\r\n            best_parent = nearest_node\r\n\r\n            for neighbor in neighbors:\r\n                if self.is_collision_free(neighbor, new_node):\r\n                    cost = cost_map[tuple(neighbor)] + np.linalg.norm(new_node - neighbor)\r\n                    if cost < min_cost:\r\n                        min_cost = cost\r\n                        best_parent = neighbor\r\n\r\n            # Add new node to tree\r\n            tree.append(new_node)\r\n            parent_map[tuple(new_node)] = tuple(best_parent)\r\n            cost_map[tuple(new_node)] = min_cost\r\n\r\n            # Rewire neighbors if new path is better\r\n            for neighbor in neighbors:\r\n                if neighbor is best_parent:\r\n                    continue\r\n\r\n                new_cost = min_cost + np.linalg.norm(new_node - neighbor)\r\n                if new_cost < cost_map[tuple(neighbor)] and self.is_collision_free(new_node, neighbor):\r\n                    parent_map[tuple(neighbor)] = tuple(new_node)\r\n                    cost_map[tuple(neighbor)] = new_cost\r\n\r\n            # Check if goal is reached\r\n            if np.linalg.norm(new_node - goal) < self.step_size:\r\n                path = self.reconstruct_path(parent_map, tuple(start), tuple(new_node))\r\n                return path\r\n\r\n        return []\r\n\r\n    def find_neighbors(self, tree, node, radius):\r\n        """Find all nodes within radius of given node"""\r\n        neighbors = []\r\n        for other_node in tree:\r\n            if np.linalg.norm(node - other_node) <= radius:\r\n                neighbors.append(other_node)\r\n        return neighbors\r\n\r\n    def sample_free_space(self):\r\n        """Sample point in free space (avoiding obstacles)"""\r\n        while True:\r\n            point = np.array([\r\n                random.uniform(self.x_min, self.x_max),\r\n                random.uniform(self.y_min, self.y_max)\r\n            ])\r\n\r\n            # Check if point is in free space\r\n            if not self.is_in_collision(point):\r\n                return point\n'})}),"\n",(0,t.jsx)(r.h3,{id:"search-based-methods",children:"Search-Based Methods"}),"\n",(0,t.jsx)(r.p,{children:"Search-based methods use graph search algorithms to find optimal paths in discretized spaces."}),"\n",(0,t.jsx)(r.h4,{id:"a-algorithm",children:"A* Algorithm"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'import heapq\r\nfrom typing import List, Tuple, Dict\r\n\r\nclass AStarNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'astar_planner\')\r\n\r\n        # Grid resolution\r\n        self.resolution = 0.5\r\n        self.grid_width = 40  # 20m x 20m with 0.5m resolution\r\n        self.grid_height = 40\r\n\r\n    def plan_path(self, start: Tuple[float, float], goal: Tuple[float, float]) -> List[Tuple[float, float]]:\r\n        """\r\n        Plan path using A* algorithm\r\n        Optimized for [USER_GPU] hardware\r\n        """\r\n        # Convert to grid coordinates\r\n        start_grid = self.world_to_grid(start)\r\n        goal_grid = self.world_to_grid(goal)\r\n\r\n        # Initialize open and closed sets\r\n        open_set = [(0, start_grid)]  # (f_score, position)\r\n        heapq.heapify(open_set)\r\n\r\n        g_score = {start_grid: 0}\r\n        f_score = {start_grid: self.heuristic(start_grid, goal_grid)}\r\n        came_from = {}\r\n\r\n        while open_set:\r\n            current = heapq.heappop(open_set)[1]\r\n\r\n            if current == goal_grid:\r\n                # Reconstruct path\r\n                return self.reconstruct_path_astar(came_from, current, start, goal)\r\n\r\n            for neighbor in self.get_neighbors(current):\r\n                if self.is_occupied(neighbor):\r\n                    continue\r\n\r\n                tentative_g_score = g_score[current] + self.distance(current, neighbor)\r\n\r\n                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\r\n                    came_from[neighbor] = current\r\n                    g_score[neighbor] = tentative_g_score\r\n                    f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, goal_grid)\r\n\r\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\r\n\r\n        return []  # No path found\r\n\r\n    def heuristic(self, a: Tuple[int, int], b: Tuple[int, int]) -> float:\r\n        """Heuristic function (Euclidean distance)"""\r\n        return np.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)\r\n\r\n    def get_neighbors(self, pos: Tuple[int, int]) -> List[Tuple[int, int]]:\r\n        """Get 8-connected neighbors"""\r\n        neighbors = []\r\n        for dx in [-1, 0, 1]:\r\n            for dy in [-1, 0, 1]:\r\n                if dx == 0 and dy == 0:\r\n                    continue  # Skip current position\r\n\r\n                new_x, new_y = pos[0] + dx, pos[1] + dy\r\n\r\n                # Check bounds\r\n                if 0 <= new_x < self.grid_width and 0 <= new_y < self.grid_height:\r\n                    neighbors.append((new_x, new_y))\r\n\r\n        return neighbors\r\n\r\n    def world_to_grid(self, pos: Tuple[float, float]) -> Tuple[int, int]:\r\n        """Convert world coordinates to grid coordinates"""\r\n        grid_x = int((pos[0] - (-10.0)) / self.resolution)  # Assuming world center at (0,0)\r\n        grid_y = int((pos[1] - (-10.0)) / self.resolution)\r\n        return (max(0, min(self.grid_width - 1, grid_x)), max(0, min(self.grid_height - 1, grid_y)))\r\n\r\n    def grid_to_world(self, grid_pos: Tuple[int, int]) -> Tuple[float, float]:\r\n        """Convert grid coordinates to world coordinates"""\r\n        world_x = grid_pos[0] * self.resolution + (-10.0) + self.resolution / 2\r\n        world_y = grid_pos[1] * self.resolution + (-10.0) + self.resolution / 2\r\n        return (world_x, world_y)\r\n\r\n    def is_occupied(self, grid_pos: Tuple[int, int]) -> bool:\r\n        """Check if grid position is occupied by obstacle"""\r\n        # This would check against a costmap\r\n        # For this example, we\'ll use the same obstacle model as RRT\r\n        world_pos = self.grid_to_world(grid_pos)\r\n        point = np.array(world_pos)\r\n\r\n        for obstacle in self.obstacles:  # From parent class\r\n            dist_to_center = np.linalg.norm(point - obstacle[\'center\'])\r\n            if dist_to_center < obstacle[\'radius\'] + self.resolution:  # Add buffer\r\n                return True\r\n        return False\r\n\r\n    def distance(self, a: Tuple[int, int], b: Tuple[int, int]) -> float:\r\n        """Calculate distance between two grid positions"""\r\n        return np.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)\r\n\r\n    def reconstruct_path_astar(self, came_from: Dict, current: Tuple[int, int],\r\n                              start: Tuple[float, float], goal: Tuple[float, float]) -> List[Tuple[float, float]]:\r\n        """Reconstruct path and convert back to world coordinates"""\r\n        path = [self.grid_to_world(current)]\r\n\r\n        while current in came_from:\r\n            current = came_from[current]\r\n            path.append(self.grid_to_world(current))\r\n\r\n        path.reverse()\r\n        return path\n'})}),"\n",(0,t.jsx)(r.h2,{id:"trajectory-generation",children:"Trajectory Generation"}),"\n",(0,t.jsx)(r.h3,{id:"polynomial-trajectories",children:"Polynomial Trajectories"}),"\n",(0,t.jsx)(r.p,{children:"Polynomial trajectories provide smooth, continuous paths with specified boundary conditions:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'import numpy as np\r\nfrom scipy.interpolate import CubicSpline\r\nimport matplotlib.pyplot as plt\r\n\r\nclass PolynomialTrajectoryGenerator:\r\n    def __init__(self):\r\n        self.max_velocity = 1.0  # m/s\r\n        self.max_acceleration = 2.0  # m/s\xb2\r\n\r\n    def generate_5th_order_trajectory(self, start_pos, start_vel, start_acc,\r\n                                     end_pos, end_vel, end_acc, duration):\r\n        """\r\n        Generate 5th order polynomial trajectory\r\n        Optimized for [USER_GPU] hardware\r\n        """\r\n        # Coefficients for 5th order polynomial: q(t) = a0 + a1*t + a2*t^2 + a3*t^3 + a4*t^4 + a5*t^5\r\n        # Boundary conditions:\r\n        # q(0) = start_pos, q\'(0) = start_vel, q\'\'(0) = start_acc\r\n        # q(T) = end_pos, q\'(T) = end_vel, q\'\'(T) = end_acc\r\n\r\n        T = duration\r\n        A = np.array([\r\n            [1, 0, 0, 0, 0, 0],           # q(0) = start_pos\r\n            [0, 1, 0, 0, 0, 0],           # q\'(0) = start_vel\r\n            [0, 0, 2, 0, 0, 0],           # q\'\'(0) = start_acc\r\n            [1, T, T**2, T**3, T**4, T**5],  # q(T) = end_pos\r\n            [0, 1, 2*T, 3*T**2, 4*T**3, 5*T**4],  # q\'(T) = end_vel\r\n            [0, 0, 2, 6*T, 12*T**2, 20*T**3]     # q\'\'(T) = end_acc\r\n        ])\r\n\r\n        b = np.array([start_pos, start_vel, start_acc, end_pos, end_vel, end_acc])\r\n        coeffs = np.linalg.solve(A, b)\r\n\r\n        return coeffs\r\n\r\n    def evaluate_trajectory(self, coeffs, t):\r\n        """Evaluate trajectory at time t"""\r\n        a0, a1, a2, a3, a4, a5 = coeffs\r\n        pos = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 + a5*t**5\r\n        vel = a1 + 2*a2*t + 3*a3*t**2 + 4*a4*t**3 + 5*a5*t**4\r\n        acc = 2*a2 + 6*a3*t + 12*a4*t**2 + 20*a5*t**3\r\n        return pos, vel, acc\r\n\r\n    def generate_trajectory_with_constraints(self, waypoints, max_vel=None, max_acc=None):\r\n        """\r\n        Generate trajectory through waypoints with velocity and acceleration constraints\r\n        Optimized for [USER_GPU] hardware\r\n        """\r\n        if max_vel is None:\r\n            max_vel = self.max_velocity\r\n        if max_acc is None:\r\n            max_acc = self.max_acceleration\r\n\r\n        trajectory = []\r\n        times = []\r\n\r\n        for i in range(len(waypoints) - 1):\r\n            start_pos = waypoints[i]\r\n            end_pos = waypoints[i + 1]\r\n\r\n            # Calculate required time based on max velocity\r\n            distance = abs(end_pos - start_pos)\r\n            min_time = distance / max_vel\r\n\r\n            # Generate polynomial segment\r\n            coeffs = self.generate_5th_order_trajectory(\r\n                start_pos, 0, 0,  # Start with zero velocity and acceleration\r\n                end_pos, 0, 0,    # End with zero velocity and acceleration\r\n                min_time\r\n            )\r\n\r\n            # Sample the trajectory segment\r\n            dt = 0.01  # 100 Hz sampling\r\n            segment_times = np.arange(0, min_time, dt)\r\n\r\n            for t in segment_times:\r\n                pos, vel, acc = self.evaluate_trajectory(coeffs, t)\r\n                trajectory.append([pos, vel, acc])\r\n                times.append(t)\r\n\r\n        return np.array(trajectory), np.array(times)\n'})}),"\n",(0,t.jsx)(r.h3,{id:"b-spline-trajectories",children:"B-Spline Trajectories"}),"\n",(0,t.jsx)(r.p,{children:"B-splines provide smooth, flexible trajectories:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'from scipy.interpolate import BSpline\r\nimport numpy as np\r\n\r\nclass BSplineTrajectoryGenerator:\r\n    def __init__(self, degree=3):\r\n        self.degree = degree  # Cubic B-spline\r\n\r\n    def generate_trajectory(self, control_points, num_points=100):\r\n        """\r\n        Generate B-spline trajectory from control points\r\n        Optimized for [USER_GPU] hardware\r\n        """\r\n        n = len(control_points)\r\n        if n < self.degree + 1:\r\n            raise ValueError(f"Need at least {self.degree + 1} control points")\r\n\r\n        # Generate knot vector (clamped)\r\n        knots = np.concatenate([\r\n            np.zeros(self.degree),\r\n            np.linspace(0, 1, n - self.degree + 1),\r\n            np.ones(self.degree)\r\n        ])\r\n\r\n        # Create parameter vector\r\n        u = np.linspace(0, 1, num_points)\r\n\r\n        # Create B-spline\r\n        bspline = BSpline(knots, control_points, self.degree)\r\n\r\n        # Evaluate trajectory\r\n        trajectory = bspline(u)\r\n\r\n        return trajectory, u\r\n\r\n    def generate_smooth_path(self, waypoints, smoothing_factor=0.1):\r\n        """\r\n        Generate smooth path through waypoints using B-splines\r\n        Optimized for [USER_GPU] hardware\r\n        """\r\n        # Use waypoints as control points for initial approximation\r\n        # Then refine to ensure path passes near waypoints\r\n        control_points = self.waypoints_to_control_points(waypoints, smoothing_factor)\r\n\r\n        trajectory, params = self.generate_trajectory(control_points)\r\n        return trajectory, params\r\n\r\n    def waypoints_to_control_points(self, waypoints, smoothing_factor):\r\n        """Convert waypoints to B-spline control points"""\r\n        # This is a simplified approach - real implementation would be more sophisticated\r\n        # For a smooth path that approximates the waypoints\r\n        waypoints = np.array(waypoints)\r\n\r\n        # Add extra points at beginning and end for better control\r\n        extra_points = 2\r\n        n = len(waypoints) + 2 * extra_points\r\n\r\n        # Create control points that will create a path through/around waypoints\r\n        control_points = np.zeros((n, 2))  # Assuming 2D for this example\r\n\r\n        # Set up control points to approximate the waypoints\r\n        for i in range(extra_points):\r\n            control_points[i] = waypoints[0]  # Start with first waypoint\r\n            control_points[-(i+1)] = waypoints[-1]  # End with last waypoint\r\n\r\n        # Distribute intermediate control points\r\n        for i in range(len(waypoints)):\r\n            idx = i + extra_points\r\n            if idx < n:\r\n                control_points[idx] = waypoints[i]\r\n\r\n        return control_points\n'})}),"\n",(0,t.jsx)(r.h2,{id:"motion-control",children:"Motion Control"}),"\n",(0,t.jsx)(r.h3,{id:"pid-control",children:"PID Control"}),"\n",(0,t.jsx)(r.p,{children:"Proportional-Integral-Derivative (PID) control is fundamental for robot control:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'class PIDController:\r\n    def __init__(self, kp=1.0, ki=0.0, kd=0.0, dt=0.01):\r\n        self.kp = kp  # Proportional gain\r\n        self.ki = ki  # Integral gain\r\n        self.kd = kd  # Derivative gain\r\n        self.dt = dt  # Time step\r\n\r\n        self.prev_error = 0.0\r\n        self.integral = 0.0\r\n\r\n    def update(self, setpoint, measurement):\r\n        """\r\n        Update PID controller with new measurement\r\n        Optimized for [USER_GPU] hardware\r\n        """\r\n        # Calculate error\r\n        error = setpoint - measurement\r\n\r\n        # Proportional term\r\n        p_term = self.kp * error\r\n\r\n        # Integral term\r\n        self.integral += error * self.dt\r\n        i_term = self.ki * self.integral\r\n\r\n        # Derivative term\r\n        derivative = (error - self.prev_error) / self.dt\r\n        d_term = self.kd * derivative\r\n\r\n        # Calculate output\r\n        output = p_term + i_term + d_term\r\n\r\n        # Store error for next iteration\r\n        self.prev_error = error\r\n\r\n        return output\r\n\r\n    def reset(self):\r\n        """Reset integral and previous error"""\r\n        self.integral = 0.0\r\n        self.prev_error = 0.0\r\n\r\nclass JointPIDController:\r\n    def __init__(self, joint_names, kp=10.0, ki=0.1, kd=0.5):\r\n        self.joint_names = joint_names\r\n        self.controllers = {\r\n            name: PIDController(kp, ki, kd) for name in joint_names\r\n        }\r\n\r\n    def update(self, desired_positions, current_positions):\r\n        """\r\n        Update PID controllers for all joints\r\n        Optimized for [USER_GPU] hardware\r\n        """\r\n        commands = {}\r\n        for i, joint_name in enumerate(self.joint_names):\r\n            if i < len(desired_positions) and i < len(current_positions):\r\n                command = self.controllers[joint_name].update(\r\n                    desired_positions[i],\r\n                    current_positions[i]\r\n                )\r\n                commands[joint_name] = command\r\n\r\n        return commands\r\n\r\n    def reset(self):\r\n        """Reset all controllers"""\r\n        for controller in self.controllers.values():\r\n            controller.reset()\n'})}),"\n",(0,t.jsx)(r.h3,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,t.jsx)(r.p,{children:"MPC uses a model of the system to predict future behavior and optimize control inputs:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'import cvxpy as cp\r\nimport numpy as np\r\n\r\nclass MPCController:\r\n    def __init__(self, prediction_horizon=10, control_horizon=5):\r\n        self.N = prediction_horizon  # Prediction horizon\r\n        self.M = control_horizon     # Control horizon\r\n        self.dt = 0.1               # Time step\r\n\r\n        # System matrices (for a simple double integrator model)\r\n        # x = [position, velocity]\r\n        self.A = np.array([[1, self.dt], [0, 1]])  # State transition matrix\r\n        self.B = np.array([[0.5 * self.dt**2], [self.dt]])  # Input matrix\r\n\r\n        # Weights for cost function\r\n        self.Q = np.eye(2) * 10  # State cost weight\r\n        self.R = np.eye(1) * 1   # Control cost weight\r\n        self.P = np.eye(2) * 50  # Terminal cost weight\r\n\r\n    def solve_mpc(self, current_state, reference_trajectory):\r\n        """\r\n        Solve MPC optimization problem\r\n        Optimized for [USER_GPU] hardware\r\n        """\r\n        # Define optimization variables\r\n        X = cp.Variable((2, self.N + 1))  # State trajectory\r\n        U = cp.Variable((1, self.M))      # Control inputs\r\n\r\n        # Cost function\r\n        cost = 0\r\n\r\n        # Running cost\r\n        for k in range(self.N):\r\n            if k < len(reference_trajectory):\r\n                ref = reference_trajectory[k]\r\n                cost += cp.quad_form(X[:, k] - ref, self.Q)\r\n\r\n        # Terminal cost\r\n        if len(reference_trajectory) > self.N:\r\n            ref = reference_trajectory[self.N]\r\n            cost += cp.quad_form(X[:, self.N] - ref, self.P)\r\n\r\n        # Control effort cost\r\n        for k in range(self.M):\r\n            cost += cp.quad_form(U[:, k], self.R)\r\n\r\n        # Constraints\r\n        constraints = []\r\n\r\n        # Initial state\r\n        constraints.append(X[:, 0] == current_state)\r\n\r\n        # System dynamics\r\n        for k in range(self.M):\r\n            constraints.append(X[:, k + 1] == self.A @ X[:, k] + self.B @ U[:, k])\r\n\r\n        # For remaining steps, keep control constant (or zero)\r\n        for k in range(self.M, self.N):\r\n            constraints.append(X[:, k + 1] == self.A @ X[:, k])  # Zero control after M\r\n\r\n        # Control limits\r\n        for k in range(self.M):\r\n            constraints.append(cp.abs(U[:, k]) <= 10.0)  # Example limit\r\n\r\n        # Create and solve optimization problem\r\n        problem = cp.Problem(cp.Minimize(cost), constraints)\r\n        problem.solve()\r\n\r\n        if problem.status not in ["infeasible", "unbounded"]:\r\n            # Return the first control input\r\n            return U[:, 0].value\r\n        else:\r\n            # Return zero control if optimization failed\r\n            return np.array([0.0])\n'})}),"\n",(0,t.jsx)(r.h3,{id:"advanced-control-techniques",children:"Advanced Control Techniques"}),"\n",(0,t.jsx)(r.h4,{id:"impedance-control",children:"Impedance Control"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'class ImpedanceController:\r\n    def __init__(self, mass=1.0, damping=10.0, stiffness=100.0):\r\n        self.M = mass      # Desired mass\r\n        self.D = damping   # Desired damping\r\n        self.K = stiffness # Desired stiffness\r\n\r\n    def compute_impedance_force(self, desired_pos, desired_vel, desired_acc,\r\n                               current_pos, current_vel, external_force=np.array([0.0, 0.0])):\r\n        """\r\n        Compute impedance control force\r\n        Optimized for [USER_GPU] hardware\r\n        """\r\n        # Position and velocity errors\r\n        pos_error = current_pos - desired_pos\r\n        vel_error = current_vel - desired_vel\r\n\r\n        # Impedance force: M*ddx + D*dx + K*x = F\r\n        impedance_force = (self.M * desired_acc +\r\n                          self.D * vel_error +\r\n                          self.K * pos_error -\r\n                          external_force)\r\n\r\n        return impedance_force\r\n\r\n    def update_trajectory(self, current_pos, current_vel, external_force, dt=0.01):\r\n        """\r\n        Update trajectory based on impedance control\r\n        Optimized for [USER_GPU] hardware\r\n        """\r\n        # This would be called in a control loop to update the reference trajectory\r\n        # based on interaction forces\r\n        pass\n'})}),"\n",(0,t.jsx)(r.h2,{id:"integration-with-ros-2-navigation",children:"Integration with ROS 2 Navigation"}),"\n",(0,t.jsx)(r.h3,{id:"custom-trajectory-controller",children:"Custom Trajectory Controller"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Twist, PoseStamped, Point\r\nfrom nav_msgs.msg import Path\r\nfrom sensor_msgs.msg import LaserScan, Imu\r\nfrom std_msgs.msg import Float64MultiArray\r\nfrom visualization_msgs.msg import Marker\r\nimport numpy as np\r\n\r\nclass TrajectoryController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'trajectory_controller\')\r\n\r\n        # Publishers\r\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\r\n        self.path_pub = self.create_publisher(Path, \'/executed_path\', 10)\r\n        self.visualization_pub = self.create_publisher(Marker, \'/trajectory_visualization\', 10)\r\n\r\n        # Subscribers\r\n        self.goal_sub = self.create_subscription(\r\n            PoseStamped, \'/move_base_simple/goal\', self.goal_callback, 10)\r\n        self.odom_sub = self.create_subscription(\r\n            Point, \'/robot_position\', self.odom_callback, 10)  # Simplified\r\n        self.scan_sub = self.create_subscription(\r\n            LaserScan, \'/scan\', self.scan_callback, 10)\r\n\r\n        # Control parameters\r\n        self.linear_vel_limit = 1.0\r\n        self.angular_vel_limit = 1.0\r\n        self.arrival_threshold = 0.1  # meters\r\n\r\n        # Current state\r\n        self.current_position = np.array([0.0, 0.0])\r\n        self.current_goal = None\r\n        self.trajectory = []\r\n        self.trajectory_index = 0\r\n\r\n        # Timer for control loop\r\n        self.control_timer = self.create_timer(0.05, self.control_loop)  # 20 Hz\r\n\r\n        self.get_logger().info(\'Trajectory controller initialized\')\r\n\r\n    def goal_callback(self, msg):\r\n        """Handle new goal"""\r\n        goal_pos = np.array([msg.pose.position.x, msg.pose.position.y])\r\n        self.current_goal = goal_pos\r\n\r\n        # Plan trajectory to goal\r\n        if self.current_position is not None:\r\n            self.plan_trajectory_to_goal(self.current_position, goal_pos)\r\n\r\n    def odom_callback(self, msg):\r\n        """Update current position"""\r\n        self.current_position = np.array([msg.x, msg.y])\r\n\r\n    def scan_callback(self, msg):\r\n        """Process laser scan for obstacle avoidance"""\r\n        # This would implement dynamic obstacle avoidance\r\n        # For this example, we\'ll just log the minimum distance\r\n        if len(msg.ranges) > 0:\r\n            min_distance = min([r for r in msg.ranges if r > 0])\r\n            if min_distance < 0.5:  # Less than 0.5m to obstacle\r\n                self.get_logger().warning(f\'Obstacle detected at {min_distance:.2f}m\')\r\n\r\n    def plan_trajectory_to_goal(self, start, goal):\r\n        """Plan trajectory from start to goal"""\r\n        # For this example, we\'ll create a simple straight-line trajectory\r\n        # In practice, this would call a path planning algorithm\r\n        distance = np.linalg.norm(goal - start)\r\n        num_waypoints = max(10, int(distance / 0.1))  # 10cm between waypoints\r\n\r\n        self.trajectory = []\r\n        for i in range(num_waypoints + 1):\r\n            t = i / num_waypoints\r\n            point = start + t * (goal - start)\r\n            self.trajectory.append(point)\r\n\r\n        self.trajectory_index = 0\r\n\r\n        # Publish trajectory for visualization\r\n        self.publish_trajectory()\r\n\r\n    def control_loop(self):\r\n        """Main control loop"""\r\n        if self.current_goal is None or len(self.trajectory) == 0:\r\n            return\r\n\r\n        if self.trajectory_index >= len(self.trajectory):\r\n            # Reached end of trajectory\r\n            self.stop_robot()\r\n            return\r\n\r\n        # Get current reference position from trajectory\r\n        target_pos = self.trajectory[self.trajectory_index]\r\n\r\n        # Calculate control command\r\n        cmd_vel = self.compute_velocity_command(target_pos)\r\n\r\n        # Publish command\r\n        self.cmd_vel_pub.publish(cmd_vel)\r\n\r\n        # Check if we\'ve reached the current waypoint\r\n        distance_to_waypoint = np.linalg.norm(self.current_position - target_pos)\r\n        if distance_to_waypoint < 0.1:  # 10cm threshold\r\n            self.trajectory_index += 1\r\n\r\n        # Check if we\'ve reached the goal\r\n        distance_to_goal = np.linalg.norm(self.current_position - self.current_goal)\r\n        if distance_to_goal < self.arrival_threshold:\r\n            self.stop_robot()\r\n            self.get_logger().info(\'Reached goal position\')\r\n\r\n    def compute_velocity_command(self, target_pos):\r\n        """Compute velocity command to reach target position"""\r\n        # Calculate direction to target\r\n        direction = target_pos - self.current_position\r\n        distance = np.linalg.norm(direction)\r\n\r\n        cmd_vel = Twist()\r\n\r\n        if distance > 0.05:  # If not very close to target\r\n            # Normalize direction\r\n            direction_norm = direction / distance\r\n\r\n            # Set linear velocity proportional to distance (with limit)\r\n            cmd_vel.linear.x = min(self.linear_vel_limit, distance * 2.0)\r\n\r\n            # Set angular velocity to face target\r\n            current_angle = 0.0  # Simplified - would need actual robot orientation\r\n            target_angle = np.arctan2(direction[1], direction[0])\r\n            angle_diff = target_angle - current_angle\r\n\r\n            # Normalize angle difference to [-\u03c0, \u03c0]\r\n            while angle_diff > np.pi:\r\n                angle_diff -= 2 * np.pi\r\n            while angle_diff < -np.pi:\r\n                angle_diff += 2 * np.pi\r\n\r\n            cmd_vel.angular.z = max(-self.angular_vel_limit,\r\n                                   min(self.angular_vel_limit, angle_diff * 2.0))\r\n        else:\r\n            # Very close to target, slow down\r\n            cmd_vel.linear.x = 0.0\r\n            cmd_vel.angular.z = 0.0\r\n\r\n        return cmd_vel\r\n\r\n    def stop_robot(self):\r\n        """Stop the robot"""\r\n        cmd_vel = Twist()\r\n        cmd_vel.linear.x = 0.0\r\n        cmd_vel.angular.z = 0.0\r\n        self.cmd_vel_pub.publish(cmd_vel)\r\n\r\n    def publish_trajectory(self):\r\n        """Publish trajectory for visualization"""\r\n        if len(self.trajectory) == 0:\r\n            return\r\n\r\n        marker = Marker()\r\n        marker.header.frame_id = "map"\r\n        marker.header.stamp = self.get_clock().now().to_msg()\r\n        marker.ns = "trajectory"\r\n        marker.id = 0\r\n        marker.type = Marker.LINE_STRIP\r\n        marker.action = Marker.ADD\r\n\r\n        # Set the scale of the marker\r\n        marker.scale.x = 0.05  # Line width\r\n\r\n        # Set the color (red)\r\n        marker.color.r = 1.0\r\n        marker.color.g = 0.0\r\n        marker.color.b = 0.0\r\n        marker.color.a = 1.0\r\n\r\n        # Set the points of the line\r\n        for point in self.trajectory:\r\n            p = Point()\r\n            p.x = point[0]\r\n            p.y = point[1]\r\n            p.z = 0.0  # Assuming 2D navigation\r\n            marker.points.append(p)\r\n\r\n        self.visualization_pub.publish(marker)\n'})}),"\n",(0,t.jsx)(r.h2,{id:"hardware-specific-optimizations",children:"Hardware-Specific Optimizations"}),"\n",(0,t.jsx)(r.h3,{id:"for-nvidia-jetson-users",children:"For NVIDIA Jetson Users"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'# Jetson-specific motion planning optimizations\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nimport numpy as np\r\n\r\nclass JetsonMotionPlanner(Node):\r\n    def __init__(self):\r\n        super().__init__(\'jetson_motion_planner\')\r\n\r\n        # Optimize motion planning for Jetson\'s ARM architecture and GPU\r\n        self.setup_jetson_optimizations()\r\n\r\n        self.get_logger().info(\'Jetson-optimized motion planner initialized\')\r\n\r\n    def setup_jetson_optimizations(self):\r\n        """Configure motion planning for Jetson hardware"""\r\n        # Use optimized libraries for Jetson\r\n        # Adjust algorithm parameters for Jetson\'s capabilities\r\n        # Enable hardware acceleration where possible\r\n        # Optimized for [USER_GPU] hardware\r\n        pass\r\n\r\n    def jetson_trajectory_optimization(self, waypoints):\r\n        """\r\n        Optimize trajectory using Jetson-optimized methods\r\n        Optimized for [USER_GPU] hardware\r\n        """\r\n        # Use Jetson\'s hardware accelerators for trajectory optimization\r\n        # This would leverage Jetson\'s integrated GPU and processing units\r\n        pass\n'})}),"\n",(0,t.jsx)(r.h3,{id:"for-high-end-gpu-users",children:"For High-End GPU Users"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'# High-end GPU motion planning optimizations\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nimport torch\r\nimport numpy as np\r\n\r\nclass GPUOptimizedMotionPlanner(Node):\r\n    def __init__(self):\r\n        super().__init__(\'gpu_optimized_motion_planner\')\r\n\r\n        # Initialize GPU context for motion planning\r\n        self.device = torch.device(\'cuda\' if torch.cuda.is_available() else \'cpu\')\r\n\r\n        # Configure motion planning for high-end GPU\r\n        self.setup_gpu_optimizations()\r\n\r\n        self.get_logger().info(\'GPU-optimized motion planner initialized\')\r\n\r\n    def setup_gpu_optimizations(self):\r\n        """Configure motion planning for high-end GPU hardware"""\r\n        # Set environment variables for GPU optimization\r\n        # Enable advanced motion planning features for powerful GPUs\r\n        # Use multi-GPU processing if available\r\n        # Optimized for [USER_GPU] hardware specifications\r\n        pass\r\n\r\n    def gpu_accelerated_path_planning(self, start, goal, obstacles):\r\n        """\r\n        Perform GPU-accelerated path planning\r\n        Optimized for [USER_GPU] hardware specifications\r\n        """\r\n        # Use GPU for intensive path planning computations\r\n        # Leverage tensor cores for efficient parallel computation\r\n        # Implement batch processing for multiple queries\r\n        pass\n'})}),"\n",(0,t.jsx)(r.h2,{id:"real-time-considerations",children:"Real-time Considerations"}),"\n",(0,t.jsx)(r.h3,{id:"control-loop-timing",children:"Control Loop Timing"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'import time\r\nimport threading\r\nfrom collections import deque\r\n\r\nclass RealTimeMotionController:\r\n    def __init__(self, control_frequency=100):\r\n        self.control_frequency = control_frequency\r\n        self.control_period = 1.0 / control_frequency\r\n        self.last_execution_times = deque(maxlen=100)  # For performance monitoring\r\n\r\n    def run_control_loop(self):\r\n        """Run real-time control loop"""\r\n        rate = self.control_period\r\n        last_time = time.time()\r\n\r\n        while True:\r\n            current_time = time.time()\r\n\r\n            # Check if it\'s time for the next control cycle\r\n            if current_time - last_time >= rate:\r\n                # Measure timing\r\n                loop_start = time.time()\r\n\r\n                # Execute control algorithm\r\n                self.execute_control_cycle()\r\n\r\n                # Measure execution time\r\n                execution_time = time.time() - loop_start\r\n                self.last_execution_times.append(execution_time)\r\n\r\n                # Check for timing violations\r\n                if execution_time > rate:\r\n                    print(f"Timing violation: {execution_time:.4f}s > {rate:.4f}s")\r\n\r\n                last_time = current_time\r\n            else:\r\n                # Small sleep to prevent busy waiting\r\n                # In a real-time system, you might use more sophisticated timing\r\n                time.sleep(0.0001)\r\n\r\n    def execute_control_cycle(self):\r\n        """Execute one control cycle"""\r\n        # This would contain the actual control logic\r\n        pass\r\n\r\n    def get_timing_stats(self):\r\n        """Get timing performance statistics"""\r\n        if len(self.last_execution_times) == 0:\r\n            return None\r\n\r\n        times = list(self.last_execution_times)\r\n        return {\r\n            \'mean\': np.mean(times),\r\n            \'std\': np.std(times),\r\n            \'min\': np.min(times),\r\n            \'max\': np.max(times),\r\n            \'period\': self.control_period\r\n        }\n'})}),"\n",(0,t.jsx)(r.h2,{id:"safety-and-validation",children:"Safety and Validation"}),"\n",(0,t.jsx)(r.h3,{id:"trajectory-validation",children:"Trajectory Validation"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'class TrajectoryValidator:\r\n    def __init__(self, max_velocity=1.0, max_acceleration=2.0, max_jerk=10.0):\r\n        self.max_vel = max_velocity\r\n        self.max_acc = max_acceleration\r\n        self.max_jerk = max_jerk\r\n\r\n    def validate_trajectory(self, trajectory):\r\n        """\r\n        Validate trajectory for safety constraints\r\n        Optimized for [USER_GPU] hardware\r\n        """\r\n        if len(trajectory) < 2:\r\n            return True  # Trivially valid\r\n\r\n        # Check velocity constraints\r\n        for i in range(1, len(trajectory)):\r\n            pos1 = trajectory[i-1][:2]  # Assuming [x, y, ...]\r\n            pos2 = trajectory[i][:2]\r\n            dt = 0.01  # Assuming 100Hz control\r\n\r\n            velocity = np.linalg.norm(pos2 - pos1) / dt\r\n            if velocity > self.max_vel:\r\n                return False, f"Velocity limit exceeded: {velocity:.2f} > {self.max_vel}"\r\n\r\n        # Check acceleration constraints (approximate)\r\n        for i in range(2, len(trajectory)):\r\n            pos0 = trajectory[i-2][:2]\r\n            pos1 = trajectory[i-1][:2]\r\n            pos2 = trajectory[i][:2]\r\n            dt = 0.01\r\n\r\n            vel1 = (pos1 - pos0) / dt\r\n            vel2 = (pos2 - pos1) / dt\r\n            acceleration = np.linalg.norm(vel2 - vel1) / dt\r\n\r\n            if acceleration > self.max_acc:\r\n                return False, f"Acceleration limit exceeded: {acceleration:.2f} > {self.max_acc}"\r\n\r\n        return True, "Trajectory is valid"\n'})}),"\n",(0,t.jsx)(r.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Path Planning"}),": Different algorithms (RRT, A*, etc.) are suitable for different environments and requirements."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Trajectory Generation"}),": Smooth trajectories require careful consideration of continuity and dynamic constraints."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Control Systems"}),": PID, MPC, and other control methods each have their strengths for different applications."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Real-time Performance"}),": Motion planning and control must meet strict timing requirements for stable operation."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Hardware Optimization"}),": Different strategies are needed for different hardware platforms (Jetson vs. high-end GPUs)."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Safety Validation"}),": Trajectories must be validated against velocity, acceleration, and jerk limits."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Integration"}),": Motion planning systems must work seamlessly with perception and higher-level planning."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"practice-exercises",children:"Practice Exercises"}),"\n",(0,t.jsx)(r.h3,{id:"exercise-1-basic-path-planning",children:"Exercise 1: Basic Path Planning"}),"\n",(0,t.jsx)(r.p,{children:"Implement an A* path planner for a 2D grid map and visualize the resulting path."}),"\n",(0,t.jsx)(r.h3,{id:"exercise-2-trajectory-generation",children:"Exercise 2: Trajectory Generation"}),"\n",(0,t.jsx)(r.p,{children:"Create a trajectory generator that produces smooth paths through waypoints with velocity and acceleration constraints."}),"\n",(0,t.jsx)(r.h3,{id:"exercise-3-pid-control",children:"Exercise 3: PID Control"}),"\n",(0,t.jsx)(r.p,{children:"Implement a PID controller for a simulated robot and tune the parameters for stable control."}),"\n",(0,t.jsx)(r.h3,{id:"exercise-4-obstacle-avoidance",children:"Exercise 4: Obstacle Avoidance"}),"\n",(0,t.jsx)(r.p,{children:"Add dynamic obstacle avoidance to your path planner using sensor feedback."}),"\n",(0,t.jsx)(r.h3,{id:"exercise-5-hardware-optimization",children:"Exercise 5: Hardware Optimization"}),"\n",(0,t.jsx)(r.p,{children:"Optimize your motion planning algorithm for your specific hardware configuration (GPU/Jetson) and measure performance improvements."}),"\n",(0,t.jsx)(r.h2,{id:"mcqs-quiz",children:"MCQs Quiz"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"What does RRT stand for in motion planning?"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"A) Rapidly-exploring Random Tree"}),"\n",(0,t.jsx)(r.li,{children:"B) Real-time Robot Trajectory"}),"\n",(0,t.jsx)(r.li,{children:"C) Robust Robot Navigation"}),"\n",(0,t.jsx)(r.li,{children:"D) Reactive Route Tracker"}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.strong,{children:"Answer: A"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"Which control method uses a model to predict future system behavior?"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"A) PID Control"}),"\n",(0,t.jsx)(r.li,{children:"B) Model Predictive Control (MPC)"}),"\n",(0,t.jsx)(r.li,{children:"C) Fuzzy Logic Control"}),"\n",(0,t.jsx)(r.li,{children:"D) On-Off Control"}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.strong,{children:"Answer: B"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"What is the primary purpose of trajectory smoothing?"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"A) To reduce computation time only"}),"\n",(0,t.jsx)(r.li,{children:"B) To ensure continuous position, velocity, and acceleration"}),"\n",(0,t.jsx)(r.li,{children:"C) To increase robot speed"}),"\n",(0,t.jsx)(r.li,{children:"D) To eliminate the need for sensors"}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.strong,{children:"Answer: B"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"Which polynomial order is typically used for trajectory generation with position, velocity, and acceleration constraints?"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"A) 2nd order"}),"\n",(0,t.jsx)(r.li,{children:"B) 3rd order"}),"\n",(0,t.jsx)(r.li,{children:"C) 5th order"}),"\n",(0,t.jsx)(r.li,{children:"D) 7th order"}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.strong,{children:"Answer: C"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsx)(r.p,{children:"What is a key advantage of sampling-based path planning methods?"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"A) Guaranteed optimal solutions"}),"\n",(0,t.jsx)(r.li,{children:"B) Fast computation in high-dimensional spaces"}),"\n",(0,t.jsx)(r.li,{children:"C) Perfect path smoothness"}),"\n",(0,t.jsx)(r.li,{children:"D) Deterministic results"}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.strong,{children:"Answer: B"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:'"Planning Algorithms" by Steven LaValle'}),"\n",(0,t.jsx)(r.li,{children:'"Robotics: Modelling, Planning and Control" by Siciliano et al.'}),"\n",(0,t.jsx)(r.li,{children:'"Introduction to Autonomous Robots" by Siegwart et al.'}),"\n",(0,t.jsx)(r.li,{children:'"Optimal Control Theory" by Kirk'}),"\n",(0,t.jsxs)(r.li,{children:["ROS 2 Navigation: ",(0,t.jsx)(r.a,{href:"https://navigation.ros.org/",children:"https://navigation.ros.org/"})]}),"\n",(0,t.jsxs)(r.li,{children:["OMPL (Open Motion Planning Library): ",(0,t.jsx)(r.a,{href:"https://ompl.kavrakilab.org/",children:"https://ompl.kavrakilab.org/"})]}),"\n",(0,t.jsxs)(r.li,{children:["MoveIt! Motion Planning Framework: ",(0,t.jsx)(r.a,{href:"https://moveit.ros.org/",children:"https://moveit.ros.org/"})]}),"\n"]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.em,{children:"Generated with reusable Claude Subagents & Spec-Kit Plus"})})]})}function p(n={}){const{wrapper:r}={...(0,o.R)(),...n.components};return r?(0,t.jsx)(r,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,r,e)=>{e.d(r,{R:()=>a,x:()=>s});var t=e(6540);const o={},i=t.createContext(o);function a(n){const r=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(r):{...r,...n}},[r,n])}function s(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),t.createElement(i.Provider,{value:r},n.children)}}}]);